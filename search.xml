<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Intel &amp; AMD 指令集之间的差异</title>
    <url>/Intel_AMD_ISA_difference.html</url>
    <content><![CDATA[<p>促进我写这篇文章的起因是，线上机器会使用基于 SPDK 的云盘存储方案，需要编译一个 RPM 包。<br>这个包在 Intel 机器是运行正常的，在 AMD 的机器上无法运行报不支持 AVX512 指令。</p>
<p>这个问题很常见，是指令集不兼容造成的。AMD 虽然是 x86 厂商，即使是同一代其生产的 CPU 也不是和 Intel 的 CPU 是指令集完全兼容的。两家厂商的 CPU 会有一些对方不支持的指令集。</p>
<p>出现问题的原因也很简单，这个 RPM 包是在一台编译机器上编译的，这台编译机器是 Intel 机器，正好支持部分 AVX512 指令集。但线上的 AMD 机器是不支持 AVX512 指令集的。解决这个问题很简单，只要使用 I 家 和 A 家 这两款 CPU 共同支持的指令集即可。实际上，是不需要我们手动对比指令集的差异，寻找交集。因为 CPU 指令集之间的差异会对软件的移植性造成重大影响，所以业界早早就有了对应的指令集基线(baseline)。</p>
<h2 id="指令集的演进"><a href="#指令集的演进" class="headerlink" title="指令集的演进"></a>指令集的演进</h2><p>gcc 编译器执行 <code>gcc -Q --help=target</code>，输出会包含如下部分,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Known valid arguments <span class="keyword">for</span> -march= option:</span><br><span class="line">  i386 i486 i586 pentium lakemont pentium-mmx [...]</span><br></pre></td></tr></table></figure>
<p>其中 march option 下面罗列的就是 gcc 的支持的各种指令集，重点关注其中 <code>x86-64/x86-64-v2/x86-64-v3/x86-64-v4</code> 这几个，这几个是 x86 平台最常用的指令集了。绝大多数软件都会使用这几个指令集进行编译，保证不同 CPU 之间的指令集兼容。<br>指令集从 x86-64 到 x86-64-v4 ，每一个版本都往 baseline 中加入了新的指令集，性能会更好，但移植会变差，一些比较老的 CPU 可能跑不了使用 x86-64-v4 指令集编译的软件了。</p>
<ul>
<li>x86-64-v2 brings support (among other things) for vector instructions up to Streaming SIMD Extensions 4.2 (SSE4.2)  and Supplemental Streaming SIMD Extensions 3 (SSSE3), the POPCNT instruction (useful for data analysis and bit-fiddling in some data structures), and CMPXCHG16B (a two-word compare-and-swap instruction useful for concurrent algorithms).</li>
<li>x86-64-v3 adds vector instructions up to AVX2, MOVBE (for big-endian data access), and additional bit-manipulation instructions.</li>
<li>x86-64-v4 includes vector instructions from some of the AVX-512 variants.</li>
</ul>
<h2 id="对比-Intel-与-AMD-指令集差异"><a href="#对比-Intel-与-AMD-指令集差异" class="headerlink" title="对比 Intel 与 AMD 指令集差异"></a>对比 Intel 与 AMD 指令集差异</h2><p>查看两款 CPU 支持的指令集之间的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Q -march=native --help=target | grep enabled</span><br></pre></td></tr></table></figure>
<p>当 march 为 native 可以获得当前 CPU 支持的所有指令集。</p>
<p>表格中是 AMD EPYC 和 Intel Ice Lake CPU 的其中一款 CPU 指令集差异图， 两家的 CPU 每一代都会有各种各样的型号，这里是其中两款的对比，<br>从图中看到，这个两款 CPU 都是比较新的，均支持 AVX512 系列指令集。两款 CPU 支持的指令集大部分都是重合的，一小部分是自家 CPU 独有的。如果我们使用 <code>-march=native </code> 在其中一款 CPU 上编译软件，计划运行在这两款 CPU 上，那么编译器使用到了任何一家的独有的指令集，软件在这两款 CPU 上就存在移植性问题了。</p>
<table>
<thead>
<tr>
<th><strong>AMD EPYC Bergamo</strong></th>
<th>仅 AMD 支持</th>
<th>仅 Intel 支持</th>
<th><strong>Intel Ice Lake</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-m128bit-long-double</td>
<td></td>
<td></td>
<td>-m128bit-long-double</td>
</tr>
<tr>
<td>-m64</td>
<td></td>
<td></td>
<td>-m64</td>
</tr>
<tr>
<td>-m80387</td>
<td></td>
<td></td>
<td>-m80387</td>
</tr>
<tr>
<td>-mabm</td>
<td></td>
<td></td>
<td>-mabm</td>
</tr>
<tr>
<td>-madx</td>
<td></td>
<td></td>
<td>-madx</td>
</tr>
<tr>
<td>-maes</td>
<td></td>
<td></td>
<td>-maes</td>
</tr>
<tr>
<td>-malign-stringops</td>
<td></td>
<td></td>
<td>-malign-stringops</td>
</tr>
<tr>
<td>-mavx</td>
<td></td>
<td></td>
<td>-mavx</td>
</tr>
<tr>
<td>-mavx2</td>
<td></td>
<td></td>
<td>-mavx2</td>
</tr>
<tr>
<td>-mavx512bf16</td>
<td><strong>AMD ONLY</strong></td>
<td></td>
<td>-mavx512bitalg</td>
</tr>
<tr>
<td>-mavx512bitalg</td>
<td></td>
<td></td>
<td>-mavx512bw</td>
</tr>
<tr>
<td>-mavx512bw</td>
<td></td>
<td></td>
<td>-mavx512cd</td>
</tr>
<tr>
<td>-mavx512cd</td>
<td></td>
<td></td>
<td>-mavx512dq</td>
</tr>
<tr>
<td>-mavx512dq</td>
<td></td>
<td></td>
<td>-mavx512f</td>
</tr>
<tr>
<td>-mavx512f</td>
<td></td>
<td></td>
<td>-mavx512ifma</td>
</tr>
<tr>
<td>-mavx512ifma</td>
<td></td>
<td></td>
<td>-mavx512vbmi</td>
</tr>
<tr>
<td>-mavx512vbmi</td>
<td></td>
<td></td>
<td>-mavx512vbmi2</td>
</tr>
<tr>
<td>-mavx512vbmi2</td>
<td></td>
<td></td>
<td>-mavx512vl</td>
</tr>
<tr>
<td>-mavx512vl</td>
<td></td>
<td></td>
<td>-mavx512vnni</td>
</tr>
<tr>
<td>-mavx512vnni</td>
<td></td>
<td></td>
<td>-mavx512vpopcntdq</td>
</tr>
<tr>
<td>-mavx512vpopcntdq</td>
<td></td>
<td></td>
<td>-mbmi</td>
</tr>
<tr>
<td>-mbmi</td>
<td></td>
<td></td>
<td>-mbmi2</td>
</tr>
<tr>
<td>-mbmi2</td>
<td></td>
<td></td>
<td>-mclflushopt</td>
</tr>
<tr>
<td>-mclflushopt</td>
<td></td>
<td></td>
<td>-mclwb</td>
</tr>
<tr>
<td>-mclwb</td>
<td></td>
<td></td>
<td>-mcrc32</td>
</tr>
<tr>
<td>-mclzero</td>
<td><strong>AMD ONLY</strong></td>
<td></td>
<td>-mcx16</td>
</tr>
<tr>
<td>-mcrc32</td>
<td></td>
<td></td>
<td>-mf16c</td>
</tr>
<tr>
<td>-mcx16</td>
<td></td>
<td></td>
<td>-mfancy-math-387</td>
</tr>
<tr>
<td>-mf16c</td>
<td></td>
<td></td>
<td>-mfma</td>
</tr>
<tr>
<td>-mfancy-math-387</td>
<td></td>
<td></td>
<td>-mfp-ret-in-387</td>
</tr>
<tr>
<td>-mfma</td>
<td></td>
<td></td>
<td>-mfsgsbase</td>
</tr>
<tr>
<td>-mfp-ret-in-387</td>
<td></td>
<td></td>
<td>-mfxsr</td>
</tr>
<tr>
<td>-mfsgsbase</td>
<td></td>
<td><strong>Intel ONLY</strong></td>
<td>-mgfni</td>
</tr>
<tr>
<td>-mfxsr</td>
<td></td>
<td></td>
<td>-mglibc</td>
</tr>
<tr>
<td>-mglibc</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-mhard-float</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-mhard-float</td>
<td></td>
<td><strong>Intel ONLY</strong></td>
<td>-mhle</td>
</tr>
<tr>
<td>-mieee-fp</td>
<td></td>
<td></td>
<td>-mieee-fp</td>
</tr>
<tr>
<td>-mlong-double-80</td>
<td></td>
<td></td>
<td>-mlong-double-80</td>
</tr>
<tr>
<td>-mlzcnt</td>
<td></td>
<td></td>
<td>-mlzcnt</td>
</tr>
<tr>
<td>-mmmx</td>
<td></td>
<td></td>
<td>-mmmx</td>
</tr>
<tr>
<td>-mmovbe</td>
<td></td>
<td></td>
<td>-mmovbe</td>
</tr>
<tr>
<td>-mmwait</td>
<td></td>
<td></td>
<td>-mmwait</td>
</tr>
<tr>
<td>-mpclmul</td>
<td></td>
<td></td>
<td>-mpclmul</td>
</tr>
<tr>
<td>-mpopcnt</td>
<td></td>
<td></td>
<td>-mpopcnt</td>
</tr>
<tr>
<td>-mprfchw</td>
<td></td>
<td></td>
<td>-mprfchw</td>
</tr>
<tr>
<td>-mpush-args</td>
<td></td>
<td></td>
<td>-mpush-args</td>
</tr>
<tr>
<td>-mrdpid</td>
<td><strong>AMD ONLY</strong></td>
<td></td>
<td>-mrdrnd</td>
</tr>
<tr>
<td>-mrdrnd</td>
<td></td>
<td></td>
<td>-mrdseed</td>
</tr>
<tr>
<td>-mrdseed</td>
<td></td>
<td></td>
<td>-mred-zone</td>
</tr>
<tr>
<td>-mred-zone</td>
<td></td>
<td><strong>Intel ONLY</strong></td>
<td>-mrtm</td>
</tr>
<tr>
<td>-msahf</td>
<td></td>
<td></td>
<td>-msahf</td>
</tr>
<tr>
<td>-msha</td>
<td></td>
<td></td>
<td>-msha</td>
</tr>
<tr>
<td>-msse</td>
<td></td>
<td></td>
<td>-msse</td>
</tr>
<tr>
<td>-msse2</td>
<td></td>
<td></td>
<td>-msse2</td>
</tr>
<tr>
<td>-msse3</td>
<td></td>
<td></td>
<td>-msse3</td>
</tr>
<tr>
<td>-msse4</td>
<td></td>
<td></td>
<td>-msse4</td>
</tr>
<tr>
<td>-msse4.1</td>
<td></td>
<td></td>
<td>-msse4.1</td>
</tr>
<tr>
<td>-msse4.2</td>
<td></td>
<td></td>
<td>-msse4.2</td>
</tr>
<tr>
<td>-msse4a</td>
<td><strong>AMD ONLY</strong></td>
<td></td>
<td>-mssse3</td>
</tr>
<tr>
<td>-mssse3</td>
<td></td>
<td></td>
<td>-mstv</td>
</tr>
<tr>
<td>-mstv</td>
<td></td>
<td></td>
<td>-mtls-direct-seg-refs</td>
</tr>
<tr>
<td>-mtls-direct-seg-refs</td>
<td></td>
<td></td>
<td>-mvaes</td>
</tr>
<tr>
<td>-mvaes</td>
<td></td>
<td></td>
<td>-mvpclmulqdq</td>
</tr>
<tr>
<td>-mvpclmulqdq</td>
<td></td>
<td></td>
<td>-mvzeroupper</td>
</tr>
<tr>
<td>-mvzeroupper</td>
<td></td>
<td></td>
<td>-mwbnoinvd</td>
</tr>
<tr>
<td>-mwbnoinvd</td>
<td></td>
<td></td>
<td>-mxsave</td>
</tr>
<tr>
<td>-mxsave</td>
<td></td>
<td></td>
<td>-mxsavec</td>
</tr>
<tr>
<td>-mxsavec</td>
<td></td>
<td></td>
<td>-mxsaveopt</td>
</tr>
<tr>
<td>-mxsaveopt</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="指令集的基线-baseline"><a href="#指令集的基线-baseline" class="headerlink" title="指令集的基线 baseline"></a>指令集的基线 baseline</h2><p>不同 CPU 指令集之间的差异，会导致软件的移植性产生重大影响。通常的情况下，我们希望我在 x86 平台编译的软件，能在任意 x86 机器（无论 Intel 还是 AMD）上运行，而不是在每一 款 CPU 上都要重新编译。这种问题就是指令集的移植性问题。</p>
<p>目前已经有解决方案了，那就是 gcc 的 <code>-march</code> 选项，通过在编译的时候指定 <code>-march</code> 实现一次编译，任意运行。<br>gcc 编译的 <code>-march</code> 选项会限定是编译过程可以使用的指令集，目前这个阶段 <code>x86-64-v2</code> 架构是当前推荐的 <code>-march</code> 选项，在性能和移植性之间取得了比较好的平衡。</p>
<p>感兴趣的小伙伴可以在不同 CPU 平台上查询 <code>x86-64-v2</code> 指令集是否存在差异，结论肯定是不存在差异，因为这是一个 baseline，已经被标准化了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -Q -march=x86<span class="number">-64</span>-v2 --help=target | grep enabled</span><br></pre></td></tr></table></figure>

<p>那这些指令集的 baseline 是怎么标准化的？<br>有些同学可能会对标准的由来感兴趣，通俗来说，是 CPU&#x2F;OS&#x2F;Compiler (具有影响力的头部)厂商大家一起坐下来开个会，在会上确定下一代指令集标准，也就是 baseline，确定后，软件厂商按照这个指令集标准编译软件，CPU 厂商按照这个标准设计 CPU。共同保证软件的移植性。其他非头部厂商也会跟进这个标准。</p>
<p><a class="link"   href="https://developers.redhat.com/blog/2021/01/05/building-red-hat-enterprise-linux-9-for-the-x86-64-v2-microarchitecture-level#" >https://developers.redhat.com/blog/2021/01/05/building-red-hat-enterprise-linux-9-for-the-x86-64-v2-microarchitecture-level#<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="其他语言-go-java-python-编译"><a href="#其他语言-go-java-python-编译" class="headerlink" title="其他语言 go&#x2F;java&#x2F;python 编译"></a>其他语言 go&#x2F;java&#x2F;python 编译</h2><p>前面的介绍，主要是 C 语言，那其他语言比如（go&#x2F;java&#x2F;python&#x2F;rust）编译的&#x2F;运行的软件是否需要考虑指令集兼容？<br><strong>理论上，所有的语言，无论是编译型还是解释性语言都会面临兼容性的问题</strong>。毕竟写的软件总要在 CPU 上跑的。。。 前面介绍 C 语言，主要是因为 C 和硬件打交道的多，对性能和可移植性都有较高的要求，其他语言更多的集中在应用层。</p>
<ul>
<li>python 是解释性语言，用户侧不存在指令集兼容问题。指令集差异在 cpython 那块。我们就认为不存在吧</li>
<li>go 是编译型语言。用户侧存在指令集兼容问题。但是因为 go 的默认配置使用的是最原始版本的 x86-64 指令集(go env 中 GOAMD64 环境变量代表是指令集版本)，所以兼容性很好。。。。我们就认为不存在吧</li>
<li>java 是运行在 JVM 上的，指令集差异在 JVM 那层被屏蔽了，和 python 情况一样。我们也认为不存在</li>
<li>rust 是编译型语言，存在指令集兼容问题，情况类似 go，取决于默认配置。</li>
</ul>
<h2 id="编译优化与可移植性的矛盾"><a href="#编译优化与可移植性的矛盾" class="headerlink" title="编译优化与可移植性的矛盾"></a>编译优化与可移植性的矛盾</h2><p>这里有一个规律，当我们使用 native 指令集(编译器使用机器上所有可用的指令集来优化) 编译的软件性能是最好的，同时可移植性也是最差的。</p>
<p>还有一个规律，所有语言都存在指令集的兼容性问题，但是实际使用中，我们并不需要考虑，这是因为语言的设计者已经将指令集兼容通过各种方式屏蔽掉了，比如 go 是使用最原始的 x86-64 指令集来屏蔽，java 通过 JVM 来屏蔽等等。</p>
<p>实际上往往只有像 C 语言会考虑指令集的兼容性，因为为了性能，编译器应该使用所有支持的指令集进行编译期优化，但是为了可移植性，又不能使用独有指令集。这本身就是一个矛盾。举个例子，像 DPDK&#x2F;SPDK 这种专门为了性能而生的软件框架，他们在编译的时候，默认采用 native 进行编译，实际上为了可移植性，我么在编译时会使用 x86-64-v2&#x2F;corei7 这些指令集，牺牲一些性能，提高可移植性。</p>
<p>在现实场景中，如果 CPU 型号是可控的，那么在编译时候，可以激进一些。如果 CPU 型号不可控的，那么还是保守一些。</p>
]]></content>
      <tags>
        <tag>ISA</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 15-445 Fall 2022 Project0: C++ Primer</title>
    <url>/cmu-15-445-fall-2022-project0-cpp-primer.html</url>
    <content><![CDATA[<p>这个项目是使用 Modern C++ 17 实现一个 字典树（<code>Trie</code>）<br>项目难点在于理解项目里如何使用 TrieNode 和 TrieTerminalNode 来组合实现一个 Trie Tree。另外一个难点是对 unique_ptr 的理解。理解 unique_ptr 智能指针对生命周期的管理。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目提供了图对 Trie Tree 介绍的，理解这两张图，基本理解了这个项目里我们需要实现什么了。<br>下面这张图是我们最终实现的 Trie Tree。图中红色的格子是要实现的 Terminal Node（TrieNodeWithValue），<br>图中包含字母的格子是要实现的 Trie Node。其中 Terminal Node 算是 Trie Node 的一个特殊情况。</p>
<p>回来继续介绍 TrieNode，他有三个成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> key_char_;</span><br><span class="line"><span class="type">bool</span> is_end_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::unordered_map&lt;<span class="type">char</span>, std::unique_ptr&lt;TrieNode&gt;&gt; children_;</span><br></pre></td></tr></table></figure>
<p><code>key_char_</code> 是路径的字符，比如 H，A，E<br><code>is_end_</code> 是表示当前 Node 是否是 Terminal Node，默认初始化为 false<br><code>children_</code> 是一个 hashmap，key 是当前节点的 <code>key_char_</code> ，value 是一个指向下一个节点的独占指针 unique_ptr 。图中代表 <code>children_</code> 是 T 和 V 的那一部分。T 和 V 都是 A 节点的子节点。<br><img   src="/../img/1685814840719-8f6f1d8e-6e09-4030-bdb3-d65e14f17057.png"  alt="image.png"></p>
<p>为什么说 Terminal Node 是 Trie Node 的特殊情况，因为项目中TrieNodeWithValue 是从 TrieNode 继承过来的，算是子类了。<br>比如，我们现在要用 Trie Tree 存储N个键值对，其中两个键值对是 (ab, 1) (ac, “val”) 。那么他们存放在书上就是下图展示的样子，因为我们要实现的 TrieNodeWithValue 的 value 被设计成支持任意类型的 value 存储，所以 TrieNodeWithValue 是一个模板类。<br><img   src="/../img/1685814852620-97e656e5-5d1b-4825-8b3c-580e59a63b3b.png"  alt="image.png"></p>
<h1 id="实现-TrieNode"><a href="#实现-TrieNode" class="headerlink" title="实现 TrieNode"></a>实现 TrieNode</h1><h2 id="InsertChildNode-GetChildNode-RemoveChildNode"><a href="#InsertChildNode-GetChildNode-RemoveChildNode" class="headerlink" title="InsertChildNode &amp; GetChildNode &amp; RemoveChildNode"></a>InsertChildNode &amp; GetChildNode &amp; RemoveChildNode</h2><p>实现 ChildNode 相关操作就是玩 unordered_map 。C++ 里面是 unordered_map 就是通常所说的 hashmap。<br><img   src="/../img/1685814082740-b9cc70ec-2a11-498f-9230-af89469726ac.png"  alt="image.png"><br><img   src="/../img/1685814148701-eb8add28-1474-4ec5-b18e-718690c95809.png"  alt="image.png"><br><img   src="/../img/1685814178989-21743ecf-471d-4df5-8854-540ff1b1a2cf.png"  alt="image.png"></p>
<h1 id="实现-TrieNodeWithValue"><a href="#实现-TrieNodeWithValue" class="headerlink" title="实现 TrieNodeWithValue"></a>实现 TrieNodeWithValue</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>第一次碰到这个函数，有一点懵，没明白子类怎么移动构造，现在想想其实很简单，利用初始化列表将父类 move，然后在大括号里最定制化修改。果然， C++ 好久不用就容易忘。<br><img   src="/../img/1685814224952-0f2eb4d9-6b50-44f5-a46e-2de2d6a803d6.png"  alt="image.png"></p>
<h1 id="实现-Trie"><a href="#实现-Trie" class="headerlink" title="实现 Trie"></a>实现 Trie</h1><h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><p>我们 <code>root_</code> Node 是一个空节点，而且要是一个由 unique_ptr 管理的 TrieNode。最初时候没想到使用 make_unique 来构造一个，想了挺久的（蠢哭了……）<br><img   src="/../img/1685814249460-e7710c91-d861-4e26-8ba2-33394a92c6ba.png"  alt="image.png"></p>
<h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>项目要求要支持并发访问，加锁是必须的了。当然在实现的视线可以先实现不加锁版本的 Insert 保证代码没有逻辑错误，然后再为代码加锁。<br>其实我的最初版本，我的逻辑代码和加锁是混合在一起的，各种 for loop 中间 return，有了 return 就需要在 return 之前把之前加的锁释放掉。。。就挺混乱的，另外因为多个 return 位置，容易忘记解锁。<br>后来，我参考内核调度器那块代码，把解锁放到函数末尾做，当代码中需要 return 的时候，用 goto 跳转到 out label，这样也就统一了解锁的位置，代码看起来舒服多了。<br>其实更好的办法是像 DPDK 那样实现一个 unsafe 版本的函数，在实现一个 safe 版本的，锁加在 safe 版本的函数里，在 safe 调用 unsafe 函数，这样实现了逻辑代码和加锁代码分离。唯一的缺点可能是锁的粒度大，不容易优化锁的粒度吧。</p>
<p>首先从 <code>root_</code> 的指针，开始遍历 Tree，执行插入操作<br>我们选择是遍历整个 string，我们把 string 分成两部分，[0, key.size()-1) 和 [key.size()-1] 两部分来实现。这样写的代码更加简单，感觉项目里的注释描述稍微有点引导学生将字符串分成两部分处理。其实完全没有必要，这样作为一个整体处理逻辑也更简单。<br>遍历整个 string 会把整个路径所有节点类型设置为 TrieNode，所以最后需要将 Terminal Node move 一下，转为  TrieNodeWithValue 类型。然后让 unique_ptr 指针指向 TrieNodeWithValue即可。<br><img   src="/../img/1685814266393-3af38181-5068-4c7c-9de9-5d61d4539944.png"  alt="image.png"></p>
<h2 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h2><p>删除要求如果需要中间节点没有 child 节点，这个节点也需要被 remove 掉。这就说明在遍历的时候我们要记录父节点的指针，但是指针一旦调到下一个节点，就回不去了，我们用的也不是双向版本的指针。所有，我们要记录我们的遍历的路径，我们用 vector 存，其实用 stack 也没问题。<br>最终，我们先遍历一遍 string，走到底部。然后开始反向遍历，检查节点有没有子节点，没有就将节点删除。<br><img   src="/../img/1685814387701-325c9397-b39d-4577-8dc8-1abf27a9dd2c.png"  alt="image.png"></p>
<h2 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h2><p>从 <code>root_</code> 开始遍历,项目要求检查存储在 Terminal Node 的 value 类型。这里借助 <code>dynamic_cast</code>  来判断。<br><img   src="/../img/1685814364319-80f212cb-0856-424b-b227-1a8582a6fb66.png"  alt="image.png"></p>
<h1 id="Gradescope"><a href="#Gradescope" class="headerlink" title="Gradescope"></a>Gradescope</h1><p><img   src="/../img/1685818990987-6e025706-9621-4ca9-b691-6b4a81f141aa.png"  alt="image.png"></p>
]]></content>
      <categories>
        <category>cmu15445</category>
      </categories>
      <tags>
        <tag>cmu15445</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU 15-445 Fall 2022 Project1: Buffer Pool</title>
    <url>/cmu-15-445-fall-2022-project1-buffer-pool.html</url>
    <content><![CDATA[<p>这个项目是实现 bpm，简而言之是实现一个磁盘缓冲区，用于加速数据库应用的 IO 操作。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>众所周知，磁盘（SSD&#x2F;HDD）的访问速度是很慢的，内存 DRAM 访问相比较很快了。我们希望为磁盘经常访问的数据在内存建立对应的缓存来加速数据库应用的访问延迟。</p>
<p>那我们把所有的数据都搬到内存里不就行了？</p>
<p>说的有道理，但我们不能这样做，一个原因是我们不是内存数据库(e.g. redis)，我们是类似 <a class="link"   href="https://www.mysql.com/" >MySQL<i class="fas fa-external-link-alt"></i></a> &#x2F; <a class="link"   href="https://www.postgresql.org/" >PostgreSQL<i class="fas fa-external-link-alt"></i></a> 的 disk-based 磁盘数据库，主要解决数据的持久化存储问题，因此数据是存储在磁盘上的。同时因为数据量会很大，如果将持久性数据库的所有数据全部搬到内存里对内存需求会很大，需要购买更多的更大的内存才能满足需求。（注：<strong>内存比磁盘贵，贵很多</strong>。。。会有经济压力）</p>
<p>另外一个原因是，数据访问是具有局部性特点的，并不是所有数据都是热点数据，我们只需要在内存里缓存热点数据，保证绝大多数磁盘访问请求可以得到加速即可。</p>
<p>所以我们不能把所有磁盘的数据都搬到内存里来加速，我们请求一个固定大小的一块内存区域作为的 buffer pool，把最常用的页在内存里建立缓存。</p>
<p><img   src="/../img/1690016109627-ecdbf8d8-0857-4d21-9377-f7fac1cd53b2.png"  alt="image.png"></p>
<p>图：不同存储介质的访问延迟</p>
<p>回到项目，项目将实现 buffer pool manager 分为 3 个子任务，</p>
<ul>
<li>可扩展哈希，是一种增强型哈希。解决最简单取余 hash 的缺点。</li>
<li>LRU-K 置换，是一种增强型 LRU。解决单队列 LRU 不能应对突发访问的，导致缓存被冲掉的问题。</li>
<li>实现 bpm，利用前两个实现的数据结构。集合在一起实现 bpm 的逻辑。</li>
</ul>
<p>这个项目本身不难，主要时间在实现数据结构（雾），所以需要我们能够理解项目的设计，画出草图。是在画不出来边 debug 边画也是可以的。同时因为可以使用 STL 库，数据结构的增删查改操作显得很轻易。</p>
<h1 id="Task-1-Extendible-Hash-Table"><a href="#Task-1-Extendible-Hash-Table" class="headerlink" title="Task 1 Extendible Hash Table"></a>Task 1 Extendible Hash Table</h1><p>Task 1 是需要实现一个 Extendible Hashtable，原理很好懂，难点在于实现，有不少细节需要注意。<br>实现步骤：首先实现  Bucket 增删查改，然后实现 ExtendibleHashTable 增删查改。</p>
<h2 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h2><h3 id="Find-Remove-Insert"><a href="#Find-Remove-Insert" class="headerlink" title="Find &amp; Remove &amp; Insert"></a>Find &amp; Remove &amp; Insert</h3><p>属于 <code>std:list</code> 数据结构的增删查改的一部分。<br>值得欣喜的是可以使用 C++17 的结构化绑定语法了，会比写 first、second 优雅很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::Bucket::<span class="built_in">Find</span>(<span class="type">const</span> K &amp;key, V &amp;value) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// Structured Binding make code looks pretty</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : list_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">      value = v;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::Bucket::<span class="built_in">Remove</span>(<span class="type">const</span> K &amp;key) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = list_.<span class="built_in">begin</span>(); it != list_.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;first == key) &#123;</span><br><span class="line">      list_.<span class="built_in">erase</span>(it);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::Bucket::<span class="built_in">Insert</span>(<span class="type">const</span> K &amp;key, <span class="type">const</span> V &amp;value) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// Check if a key already exists in the bucket.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : list_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">      <span class="comment">// Key already exists, update the value and return true.</span></span><br><span class="line">      v = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Key doesn&#x27;t exist, add a new pair if the bucket isn&#x27;t full.</span></span><br><span class="line">  <span class="keyword">if</span> (list_.<span class="built_in">size</span>() &lt; size_) &#123;</span><br><span class="line">    list_.<span class="built_in">emplace_back</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Bucket is full, return false.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ExtendibleHashTable"><a href="#ExtendibleHashTable" class="headerlink" title="ExtendibleHashTable"></a>ExtendibleHashTable</h2><p>有了前面对 Bucket 增删查改的支持后，现在我们可以实现对 ExtendibleHashTable 的增删查改了。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>需要实现 ExtendibleHashTable 的构造函数，使用<code>emplace_back</code> 代替 <code>push_back</code>获得更好的性能。<code>push_back</code> 会将对象复制一遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">ExtendibleHashTable</span>(<span class="type">size_t</span> bucket_size)</span><br><span class="line">: <span class="built_in">global_depth_</span>(<span class="number">0</span>), <span class="built_in">bucket_size_</span>(bucket_size), <span class="built_in">num_buckets_</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;Bucket&gt;(bucket_size_, <span class="number">0</span>);</span><br><span class="line">    dir_.<span class="built_in">emplace_back</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h3><p>查找到 key 对应的bucket，然后到对应的 bucket 里面找，这里可以调用 Bucket 实现的 Find。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">Find</span>(<span class="type">const</span> K &amp;key, V &amp;value) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">  <span class="keyword">auto</span> bucket = dir_[index];</span><br><span class="line">  <span class="keyword">return</span> bucket-&gt;<span class="built_in">Find</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>查找到 key 对应的bucket，然后到对应的 bucket 里面删除，这里可以调用 Bucket 实现的  Remove。我记得15445 往年的删除操作是要求实现 shink 的，现在不要求实现 shink （缩容）操作了，会更加简单一些，调用实现的 Bucket 的 api 就好了。如果要求实现 shink 操作，那么代码变得像 Insert 那样长了，不会像这样简单的几行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">Remove</span>(<span class="type">const</span> K &amp;key) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">  <span class="keyword">auto</span> bucket = dir_[index];</span><br><span class="line">  <span class="keyword">return</span> bucket-&gt;<span class="built_in">Remove</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>Insert 操作是整个 hashtable 操作的核心。<br>这里有几个部分需要介绍一下，当 <code>local_depth == global_depth_</code> 时候的 <code>dir_</code> 扩容是使用 <code>std::copy_n</code>，这段代码这是为了维护扩容后，每个新扩的 <code>dir_</code> 的索引项都会指向原先的 bucket。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> K &amp;key, <span class="type">const</span> V &amp;value) &#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">  <span class="keyword">auto</span> bucket = dir_[index];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bucket-&gt;<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">    bucket-&gt;<span class="built_in">Insert</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (bucket-&gt;<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">    <span class="comment">// If the bucket is full, split it</span></span><br><span class="line">    <span class="type">int</span> local_depth = bucket-&gt;<span class="built_in">GetDepth</span>();</span><br><span class="line">    <span class="keyword">if</span> (local_depth == global_depth_) &#123;</span><br><span class="line">      <span class="type">size_t</span> dir_size = dir_.<span class="built_in">size</span>();</span><br><span class="line">      dir_.<span class="built_in">reserve</span>(dir_size * <span class="number">2</span>);</span><br><span class="line">      std::<span class="built_in">copy_n</span>(dir_.<span class="built_in">begin</span>(), dir_size, std::<span class="built_in">back_inserter</span>(dir_));</span><br><span class="line">      global_depth_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> b0 = std::<span class="built_in">make_shared</span>&lt;Bucket&gt;(bucket_size_, local_depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> b1 = std::<span class="built_in">make_shared</span>&lt;Bucket&gt;(bucket_size_, local_depth + <span class="number">1</span>);</span><br><span class="line">    num_buckets_++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> local_mask = <span class="number">1</span> &lt;&lt; local_depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redistribute old bucket</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[k, v] : bucket-&gt;<span class="built_in">GetItems</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> new_index_of = std::<span class="built_in">hash</span>&lt;K&gt;()(k) &amp; local_mask;</span><br><span class="line">      <span class="comment">// new_index_of = &#123;0, 1&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (new_index_of) &#123;</span><br><span class="line">        b1-&gt;<span class="built_in">Insert</span>(k, v);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b0-&gt;<span class="built_in">Insert</span>(k, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update hashtable</span></span><br><span class="line">    <span class="type">size_t</span> start_index = std::<span class="built_in">hash</span>&lt;K&gt;()(key) &amp; (local_mask - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = start_index; i &lt; dir_.<span class="built_in">size</span>(); i += local_mask) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(i &amp; local_mask)) &#123;</span><br><span class="line">        dir_[i] = b1;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dir_[i] = b0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">    bucket = dir_[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// now we have enough space to insert into</span></span><br><span class="line">  dir_[index]-&gt;<span class="built_in">Insert</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h2><h3 id="how-to-debug-on-M1"><a href="#how-to-debug-on-M1" class="headerlink" title="how to debug on M1?"></a>how to debug on M1?</h3><p>m1 上可以用 lldb 来进行 debug。</p>
<ul>
<li>f 当前栈帧，等价 gdb 中的 frame。用于查看当前执行到哪里了</li>
<li>n 下一步，等价 gdb 中的 n。执行下一步。</li>
<li>p 打印，等价 gdb 中的 p。打印变量。</li>
</ul>
<p>举一个当时做项目 debug 的例子，看图，<br><img   src="/../img/1687340563374-349c877d-1bc0-48f6-8171-16b681066f11.png"  alt="image.png"></p>
<p><img   src="/../img/1687340791159-3ce16ec2-205b-49f4-9291-53d5259948df.png"  alt="image.png"></p>
<p>debug 时候会发现， lldb 打印了结构体类型就打印了很长很长，，，，这是因为 C++ STL 标准库后面隐藏了很多细节，但这些细节在 debug 时候会暴露出来了，图中可以看到 debug 时候会 lldb 输出的一个对象结构体是一层套一层。。。<br><strong>Don’t panic</strong>，不熟悉的同学可以去看看侯捷的《STL源码剖析》这本书，这本书是每一位 C++er 必看的一本书了。书中介绍了STL 标准库如何实现这些 <code>vector</code>, <code>string</code> 等高级数据结构的。b 站也有对应的视频，搭配食用，效果更好哈。</p>
<h3 id="为什么我通过不了InsertMultipleSplit-？"><a href="#为什么我通过不了InsertMultipleSplit-？" class="headerlink" title="为什么我通过不了InsertMultipleSplit ？"></a>为什么我通过不了InsertMultipleSplit ？</h3><p>InsertMultipleSplit，测试检测的是，某一次插入会造成 <code>dir_</code> 不止一次的 split。<br>通常没通过的原因是判断 <code>bucket-&gt;IsFull()</code>只判断了一次，实际需要使用 while 循环持续判断 bucket 是否满了，直到知道找到适合的位置。<br>下面解释为什么，<br>首先，这是两个测试用例，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试用例 1</span></span><br><span class="line">table-&gt;Insert(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">table-&gt;Insert(<span class="number">1024</span>, <span class="string">&quot;1024&quot;</span>);</span><br><span class="line">table-&gt;Insert(<span class="number">4</span>, <span class="string">&quot;4&quot;</span>);  <span class="comment">// this causes 3 splits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例 2</span></span><br><span class="line">table-&gt;Insert(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">table-&gt;Insert(<span class="number">1024</span>, <span class="string">&quot;1024&quot;</span>);</span><br><span class="line">table-&gt;Insert(<span class="number">16</span>, <span class="string">&quot;16&quot;</span>);  <span class="comment">// this causes 5 splits</span></span><br></pre></td></tr></table></figure>
<p>这是测试用例每个 key 的二进制表示，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bin(0)</span></span><br><span class="line">&#x27;0b0&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bin(1024)</span></span><br><span class="line">&#x27;0b10000000000&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bin(4)</span></span><br><span class="line">&#x27;0b100&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bin(16)</span></span><br><span class="line">&#x27;0b10000&#x27;</span><br></pre></td></tr></table></figure>
<p>插入导致的 split 次数和我们 <code>Indexof</code> 函数有关系的，<code>Indexof</code> 函数是判断当前的 key 应该放到那个 bucket 里面的，如果 这个 bucket 满了需要继续 split 至少找到一个可以放下 key 的 bucket。<br>那 Indexof 是如何判断应该放到那个 bucket 里的？ 比如说，现在我们有 <code>dir_</code> 表项的长度是 8，代表有 8 个 bucket ，现在有一个 key 需要被放到 8 个 bucket 中的一个，那么应该选择哪一个 bucket，用最简单的 hash 函数即可，取余 <code>index = key % 8</code>，取余之后 key 会自然落到想要的范围内。这也是项目里 <code>Indexof</code> 的实现原理，项目里取余的数不是一个固定的数 8 而是 <code>global_depth</code> 。另外项目没有采用 % 运算，而是用位运算来实现。</p>
<p>那么，我什么构造 <code>0,1024,4</code> 就能让 bucket 分裂三次？这个 <code>global_depth</code> 有关系，<code>global_depth</code> 代表需要使用多少位才能区分出所有的  bucket 。区分的方式是通过 key 对应的二进制数低位，通过增加低位的个数，直至区分出来。看上面 <code>0,1024,4</code> 三个数的二进制的低位（这里只写了 3 位）分别是 [000,000,100]，当进行插入的时候，bucket 大小是 2，只通过低位可以区别这两个数，那么 0,1024 会被放到第一个 bucket 里。插入 4 的时候，4 的低位第一位是 0，可以插入第一个 bucket 里的，但是 bucket 只能放 2 个 key，已经满了，这时候发生 split，需要通过更多的 bit 来区分两个 bucket，因为 4 的低位 bit 是[100]，0,1024 的 低位 bit 是[000] ，能区分两个 bucket 最小都要到低位第三个 bit。这也是为什么要 split 三次的原因。<br>另，测试用例 2 插入 16 也是同理，至少需要到第 5 位 bit才能区分出两个 bucket，如果插入的数字不是 16 而是 512，那么需要 split 10 次才能区分出两个 bucket。（512 的二进制表示是 <code>1000000000</code>）</p>
<h1 id="Task-2-LRU-K-Replacement-Policy"><a href="#Task-2-LRU-K-Replacement-Policy" class="headerlink" title="Task 2 LRU-K Replacement Policy"></a>Task 2 LRU-K Replacement Policy</h1><p>LRU-K 是 LRU 算法的变种，LRU 置换算法的通常用于磁盘缓存（从内核角度讲，更准确的是文件系统的缓存，文件系统有页的概念，磁盘属于块设备，没有页的概念，当然这无关精要）。<br>回到正题，通常磁盘缓存的形态是有一个队列，存放缓存的页，有对磁盘某一页的访问，就会将这个页加入缓存。缓存都会设置一定的大小，如果缓存满了，就会将最近没有访问过的页从磁盘缓存里踢掉，但是 LRU 有一个队列，比较难以应对突发访问，称为 burst。突发访问的特点是，量很大，但是只会访问一次，因为 burst 将之前的所有缓存都刷了，确实是一个问题，可以改进。<br>这时候引入两个队列（LRU-K 的K通常取 2）就可以解决这个问题，一个不活跃队列，一个活跃队列（其他叫法：历史队列&#x2F;缓存队列，冷队列&#x2F;热队列），访问页会记录访问次数，次数达到 n 次，从不活跃队列加入活跃队列。<br>这样，就能解决前面提到的 burst 的问题了。<br>这两个队列，完全是可以采用完全不同的替换策略，各自独立。比如项目里，不活跃队列要求采用 FIFO，活跃队列采用 LRU 算法。这种实现又有另一个名字叫做 2Q 策略。</p>
<p>注：不活跃使用 FIFO 队列，活跃队列采用 LRU 置换策略可能是 Task 2 最大的坑点了，理清楚 LRU 是干啥的，编码不难。项目注释说的不是很清楚，很容易两个队列都使用 LRU 置换策略。</p>
<h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LRUKReplacer::<span class="built_in">LRUKReplacer</span>(<span class="type">size_t</span> num_frames, <span class="type">size_t</span> k) : <span class="built_in">replacer_size_</span>(num_frames), <span class="built_in">k_</span>(k) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RecordAccess"><a href="#RecordAccess" class="headerlink" title="RecordAccess"></a>RecordAccess</h2><p>记录当前页被访问了，LRU-K 需要通过访问记录来控制缓存停留在不活跃队列，还是移入活跃队列。<br>LRU 算法的队列可以取队头防止最频繁访问的缓存，取队尾是新加入的缓存。也可以反过来，我采用的是队尾存放最经常访问的缓存。目的为了方便遍历的时候从队首开始，而不是从队尾开始。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(frame_id &lt; <span class="built_in">static_cast</span>&lt;<span class="type">frame_id_t</span>&gt;(replacer_size_), <span class="string">&quot;Invalid frame_id, this shouldn&#x27;t happen&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = table_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="comment">// new, should append to inactive list and update LRU-K metadata</span></span><br><span class="line">  <span class="keyword">if</span> (it == table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    inactive_list_.<span class="built_in">emplace_back</span>(frame_id);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FrameItem</span> f_item = &#123;inactive_list_.<span class="built_in">end</span>()--, <span class="number">1</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">    table_.<span class="built_in">insert</span>(&#123;frame_id, f_item&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// already in table</span></span><br><span class="line">  <span class="type">size_t</span> accs_cnt = it-&gt;second.nr_accessed_ + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (accs_cnt &lt; k_) &#123;</span><br><span class="line">    <span class="comment">// should still stay in inactive list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FrameItem</span> *f_item = &amp;(it-&gt;second);</span><br><span class="line">    f_item-&gt;nr_accessed_ = accs_cnt;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (accs_cnt == k_) &#123;</span><br><span class="line">    <span class="comment">// Promote from inactive to active</span></span><br><span class="line">    inactive_list_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">    active_list_.<span class="built_in">emplace_back</span>(frame_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FrameItem</span> *f_item = &amp;(it-&gt;second);</span><br><span class="line">    f_item-&gt;iter_ = active_list_.<span class="built_in">end</span>()--;</span><br><span class="line">    f_item-&gt;nr_accessed_ = accs_cnt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Already active, move to the active side</span></span><br><span class="line">    active_list_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">    active_list_.<span class="built_in">emplace_back</span>(frame_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FrameItem</span> *f_item = &amp;(it-&gt;second);</span><br><span class="line">    f_item-&gt;iter_ = active_list_.<span class="built_in">end</span>()--;</span><br><span class="line">    f_item-&gt;nr_accessed_ = accs_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SetEvictable"><a href="#SetEvictable" class="headerlink" title="SetEvictable"></a>SetEvictable</h2><p>将一个页标记为是否可以被 Evict 掉，2019 去年这个函数分为两个函数，叫做 pin&#x2F;unpin。感觉，还是 pin&#x2F;unpin 更容易理解一些。对 <code>nr_evictable</code> 的更新这里用了两个三元表达式简化 if 嵌套判断。不得不说，三元表达式真好用，嘿嘿。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = table_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it == table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> prev_status = it-&gt;second.evictable_;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Update evictable count based on status change</span></span><br><span class="line"><span class="comment">   * status changed ?  --&gt; (yes) update evictable count  --&gt; (false -&gt; true) increase count</span></span><br><span class="line"><span class="comment">   *                                                     --&gt; (true -&gt; false) decrease count</span></span><br><span class="line"><span class="comment">   *                   --&gt; (no) doesn&#x27;t need change</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  nr_evictable_ += (prev_status != set_evictable) ? (set_evictable ? <span class="number">1</span> : <span class="number">-1</span>) : <span class="number">0</span>;</span><br><span class="line">  it-&gt;second.evictable_ = set_evictable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Evict"><a href="#Evict" class="headerlink" title="Evict"></a>Evict</h2><p>驱逐，当缓存满了的时候，就要驱逐一些缓存页了。先从不活跃队列驱逐，如果不活跃队列里的缓存队列不满足驱逐条件，就从活跃队列驱逐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FIFO, evict should start from head</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">any_of</span>(inactive_list_.<span class="built_in">begin</span>(), inactive_list_.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">        <span class="type">bool</span> evictable = table_[f].evictable_;</span><br><span class="line">        <span class="keyword">if</span> (evictable) &#123;</span><br><span class="line">          inactive_list_.<span class="built_in">remove</span>(f);</span><br><span class="line">          nr_evictable_--;</span><br><span class="line">          table_.<span class="built_in">erase</span>(f);</span><br><span class="line">          *frame_id = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evictable;</span><br><span class="line">      &#125;)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LRU, stores the most recently used items at the tail(my solution),</span></span><br><span class="line">  <span class="comment">// so evict should start from head</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">any_of</span>(active_list_.<span class="built_in">begin</span>(), active_list_.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">        <span class="type">bool</span> evictable = table_[f].evictable_;</span><br><span class="line">        <span class="keyword">if</span> (evictable) &#123;</span><br><span class="line">          active_list_.<span class="built_in">remove</span>(f);</span><br><span class="line">          nr_evictable_--;</span><br><span class="line">          table_.<span class="built_in">erase</span>(f);</span><br><span class="line">          *frame_id = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evictable;</span><br><span class="line">      &#125;)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看，这里使用了 <code>std::anyof </code> 代替了 for 循环，这是 <code>clang-tidy </code>要求的，<code>Clang-Tidy: Replace loop by &#39;std::any_of()&#39;</code>，原先我使用 for 循环写的，目的是可以用C++17 的结构体，另外我把 LRU 活跃缓存放在队尾也是为了能在这里使用结构化绑定，多简洁。<br>后来还是换成 std::anyof 了，因为不给换项目不给过。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> f : inactive_list_) &#123;</span><br><span class="line">    <span class="type">bool</span> evictable = table_[f].evictable_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evictable) &#123;</span><br><span class="line">      inactive_list_.<span class="built_in">remove</span>(f);</span><br><span class="line">      nr_evictable_--;</span><br><span class="line">      table_.<span class="built_in">erase</span>(f);</span><br><span class="line"></span><br><span class="line">      *frame_id = f;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> f : active_list_) &#123;</span><br><span class="line">    <span class="type">bool</span> evictable = table_[f].evictable_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evictable) &#123;</span><br><span class="line">      active_list_.<span class="built_in">remove</span>(f);</span><br><span class="line">      nr_evictable_--;</span><br><span class="line">      table_.<span class="built_in">erase</span>(f);</span><br><span class="line"></span><br><span class="line">      *frame_id = f;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove-1"><a href="#Remove-1" class="headerlink" title="Remove"></a>Remove</h2><p>将一个缓存移除。需要注意的是因为，我们引入了两个队列，所以从两个队列都要扫一遍。但是是有加速方案的，就是判断访问次数，根据次数可以判断在哪个队列，避免无脑扫两次链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = table_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it == table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (it-&gt;second.nr_accessed_ &lt; k_) &#123;</span><br><span class="line">    inactive_list_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">    nr_evictable_--;</span><br><span class="line">    table_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    active_list_.<span class="built_in">remove</span>(frame_id);</span><br><span class="line">    nr_evictable_--;</span><br><span class="line">    table_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Size</span><span class="params">()</span> -&gt; <span class="type">size_t</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> nr_evictable_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DEBUG-1"><a href="#DEBUG-1" class="headerlink" title="DEBUG"></a>DEBUG</h2><p>遇到过项目要求理解错了导致测试用例 failed 的情况，<br><img   src="/../img/1689524734379-14876210-a882-4ad0-b730-bc18c50ef606.png"  alt="image.png"></p>
<p>修改成这样可以过了，项目的意思是 inactive list 用 FIFO 换出策略。active list 才采用 classic LRU 换出策略。inactive list 也采用 LRU 换出策略，会导致此测试用例 failed。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># git diff</span><br><span class="line"><span class="comment">diff --git a/src/buffer/lru_k_replacer.cpp b/src/buffer/lru_k_replacer.cpp</span></span><br><span class="line"><span class="comment">index d2f0eea..8b41fa0 100644</span></span><br><span class="line"><span class="comment">--- a/src/buffer/lru_k_replacer.cpp</span></span><br><span class="line"><span class="comment">+++ b/src/buffer/lru_k_replacer.cpp</span></span><br><span class="line"><span class="meta">@@ -67,8 +67,6 @@</span> void LRUKReplacer::RecordAccess(frame_id_t frame_id) &#123;</span><br><span class="line"></span><br><span class="line">if (accs_cnt &lt; k_) &#123;</span><br><span class="line">// should still stay in inactive list</span><br><span class="line"><span class="deletion">-    inactive_list_.remove(frame_id);</span></span><br><span class="line"><span class="deletion">-    inactive_list_.emplace_back(frame_id);</span></span><br><span class="line"></span><br><span class="line">struct FrameItem *f_item = &amp;(it-&gt;second);</span><br><span class="line">f_item-&gt;nr_accessed_ = accs_cnt;</span><br></pre></td></tr></table></figure>
<h1 id="Task-3-Buffer-Pool-Manager-Instance"><a href="#Task-3-Buffer-Pool-Manager-Instance" class="headerlink" title="Task #3 - Buffer Pool Manager Instance"></a>Task #3 - Buffer Pool Manager Instance</h1><p>实现 bpm，bpm 负责管理磁盘的页缓存。</p>
<h2 id="理解构造函数"><a href="#理解构造函数" class="headerlink" title="理解构造函数"></a>理解构造函数</h2><p>无需实现，已经实现好了。<strong>理解构造函数，对于理解 bpm 的设计具有重要意义</strong>。理解了，后面实现也会轻松很多。<br>bpm 负责管理磁盘缓存，自然会涉及磁盘页的读取和写入操作。这部分已经被逻辑实现了，无需实现，只要记得调用 <code>disk_manager_</code> 的逻辑写和读接口即可。</p>
<p>观察构造函数，我们可以发现，bpm 的成员主要是这四个，</p>
<ul>
<li>disk_manager    	负责磁盘页的读写操作</li>
<li>page_table 	记录磁盘页(page)在内存帧(frame)的映射关系，同一个东西的不同角度表示</li>
<li>replacer		缓存空间有限，缓存管理者</li>
<li>free_list		bpm 的缓存空闲链表，用完了就找 replacer 要了，让他踢掉几个不常用的页</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">BufferPoolManagerInstance::<span class="built_in">BufferPoolManagerInstance</span>(<span class="type">size_t</span> pool_size, DiskManager *disk_manager, <span class="type">size_t</span> replacer_k, LogManager *log_manager)</span><br><span class="line">    : <span class="built_in">pool_size_</span>(pool_size), <span class="built_in">disk_manager_</span>(disk_manager), <span class="built_in">log_manager_</span>(log_manager) &#123;</span><br><span class="line">  <span class="comment">// we allocate a consecutive memory space for the buffer pool</span></span><br><span class="line">  pages_ = <span class="keyword">new</span> Page[pool_size_];</span><br><span class="line">  page_table_ = <span class="keyword">new</span> <span class="built_in">ExtendibleHashTable</span>&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt;(bucket_size_);</span><br><span class="line">  replacer_ = <span class="keyword">new</span> <span class="built_in">LRUKReplacer</span>(pool_size, replacer_k);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initially, every page is in the free list.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    free_list_.<span class="built_in">emplace_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新增一个-helper-函数"><a href="#新增一个-helper-函数" class="headerlink" title="新增一个 helper 函数"></a>新增一个 helper 函数</h2><p>将寻找一个新的 frame 的操作抽象到一个函数 <code>TryToFindAvailFrame</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/include/buffer/buffer_pool_manager_instance.cpp</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief Try to find usable frame in buffer pool</span></span><br><span class="line"><span class="comment">  * @param[out] frame_id id of the page to deallocate</span></span><br><span class="line"><span class="comment">  * @return true if found, false if all frames are pined</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TryToFindAvailFrame</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/buffer/buffer_pool_manager_instance.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManagerInstance::TryToFindAvailFrame</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    *frame_id = free_list_.<span class="built_in">back</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (replacer_-&gt;<span class="built_in">Evict</span>(frame_id)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pages_[*frame_id].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[*frame_id].page_id_, pages_[*frame_id].data_);</span><br><span class="line">      pages_[*frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_-&gt;<span class="built_in">Remove</span>(pages_[*frame_id].page_id_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NewPgImp"><a href="#NewPgImp" class="headerlink" title="NewPgImp"></a>NewPgImp</h2><p>在 bpm 里新申请一个 page，会通过 Page 结构的构造函数分配一个页出来（实现代码：<code>src/include/storage/page/page.h</code>），返回是一个指向页的指针。拿到指向页的指针，应用程序可以往页里写数据了，页的大小是固定的，是通过宏定义的，不用担心只有指针却没有大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManagerInstance::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">TryToFindAvailFrame</span>(&amp;frame_id)) &#123;</span><br><span class="line">    *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">    pages_[frame_id].page_id_ = *page_id;</span><br><span class="line">    pages_[frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    page_table_-&gt;<span class="built_in">Insert</span>(*page_id, frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FetchPgImp"><a href="#FetchPgImp" class="headerlink" title="FetchPgImp"></a>FetchPgImp</h2><p>fetch 操作代表我要从磁盘将一个页取到内存中，我知道这个页的 id，我需要得到这个页在内存里的地址，因为待会应用程序需要读写这个页。<br>这里有两种情况了，如果这个页本身就在内存中，那么直接返回它的地址即可。如果不在内存，而是被换出到磁盘上了，就需要重新将磁盘的页读到内存中，然后返回页的内存地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManagerInstance::FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">  <span class="keyword">if</span> (page_table_-&gt;<span class="built_in">Find</span>(page_id, frame_id)) &#123;</span><br><span class="line">    pages_[frame_id].pin_count_++;</span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">TryToFindAvailFrame</span>(&amp;frame_id)) &#123;</span><br><span class="line">    pages_[frame_id].page_id_ = page_id;</span><br><span class="line">    pages_[frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">    pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[frame_id].data_);</span><br><span class="line"></span><br><span class="line">    page_table_-&gt;<span class="built_in">Insert</span>(page_id, frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UnpinPgImp"><a href="#UnpinPgImp" class="headerlink" title="UnpinPgImp"></a>UnpinPgImp</h2><p>对页 unpin，代表应用程序暂时不会用到这个页，指示这个页不必一直停留到内存里，可以被 bpm 换出到磁盘上，毕竟内存资源不是无限的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManagerInstance::UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">  <span class="keyword">if</span> (page_table_-&gt;<span class="built_in">Find</span>(page_id, frame_id)) &#123;</span><br><span class="line">    pages_[frame_id].pin_count_--;</span><br><span class="line">    <span class="keyword">if</span> (pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">      replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pages_[frame_id].is_dirty_ = is_dirty || pages_[frame_id].is_dirty_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FlushPgImp"><a href="#FlushPgImp" class="headerlink" title="FlushPgImp"></a>FlushPgImp</h2><p>刷页，指示 bpm 将页的内存刷回到磁盘上。通常数据库应用为了防止断掉带来的 DRAM 内存里的数据丢失，会定期刷盘，将内存数据写回磁盘。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManagerInstance::FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id;</span><br><span class="line">  <span class="keyword">if</span> (page_table_-&gt;<span class="built_in">Find</span>(page_id, frame_id)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pages_[frame_id].is_dirty_) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[frame_id].data_);</span><br><span class="line">      pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FlushAllPgsImp"><a href="#FlushAllPgsImp" class="headerlink" title="FlushAllPgsImp"></a>FlushAllPgsImp</h2><p>所有页刷回磁盘。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pages_[i].is_dirty_) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[i].page_id_, pages_[i].data_);</span><br><span class="line">      pages_[i].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Gradescope"><a href="#Gradescope" class="headerlink" title="Gradescope"></a>Gradescope</h1><p><img   src="/../img/1690008398782-42d06603-c39a-43e3-a4f5-db350ec06d78.png"  alt="image.png"></p>
]]></content>
      <categories>
        <category>cmu15445</category>
      </categories>
      <tags>
        <tag>cmu15445</tag>
        <tag>buffer pool</tag>
        <tag>extendible hash</tag>
        <tag>LRU-K</tag>
      </tags>
  </entry>
  <entry>
    <title>修改重新封装 Linux ISO</title>
    <url>/customize-linux-boot-iso.html</url>
    <content><![CDATA[<blockquote>
<p>请注意：本文档旨在帮助您根据现有的 ISO 来创建一个 自定义的ISO文件。如果您希望从零开始，可以参考OpenCloudOS ISO镜像构建项目，</p>
<p><a class="link"   href="https://gitee.com/OpenCloudOS/ocs_lorax_build_image" >https://gitee.com/OpenCloudOS/ocs_lorax_build_image<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>以 Rocky-9.4-x86_64-dvd.iso 为例，</p>
<h2 id="挂载-ISO"><a href="#挂载-ISO" class="headerlink" title="挂载 ISO"></a>挂载 ISO</h2><p>挂载 ISO 到 &#x2F;mnt 目录, 因为 ISO 镜像挂载后是只读的，因为我们需要先将 ISO 里的文件复制到新的目录，后续对 ISO 的修改在这个新的目录中进行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载 iso</span></span><br><span class="line">mount -o loop Rocky-9.4-x86_64-dvd.iso /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 ISO 文件拷贝到工作目录，本示例使用的工作目录为 /opt/iso</span></span><br><span class="line"><span class="built_in">cp</span> -a /mnt /opt/iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># umount iso</span></span><br><span class="line">umount /mnt</span><br></pre></td></tr></table></figure>

<h2 id="新增-删除-RPM-包"><a href="#新增-删除-RPM-包" class="headerlink" title="新增&#x2F;删除 RPM 包"></a>新增&#x2F;删除 RPM 包</h2><p>大多是时候，修改 ISO 是新增&#x2F;删除 RPM 包，比如更换内核包，添加自定义包等等。</p>
<p>Rocky 9.4 ISO RPM 存放目录在 AppStream 和 BaseOS 两个目录下, 与其 yum 源的目录结构相同。</p>
<p>RPM 以及 repodata, 目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tree -d 1 AppStream/</span></span><br><span class="line">AppStream/</span><br><span class="line">├── Packages</span><br><span class="line">└── repodata</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tree -d 1 BaseOS/</span></span><br><span class="line">BaseOS/</span><br><span class="line">├── Packages</span><br><span class="line">└── repodata</span><br></pre></td></tr></table></figure>

<p>子目录 Packages 存放 RPM 包文件，repodata 存放 RPM 包的元数据。在 Packages 目录下放入新的包或者删除不需要的包后，需要重新生成 repodata。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">createrepo --update AppStream/</span><br><span class="line">createrepo --update BaseOS/</span><br></pre></td></tr></table></figure>


<h2 id="ISO-换标"><a href="#ISO-换标" class="headerlink" title="ISO 换标"></a>ISO 换标</h2><p>修改 Rocky 为 CustomizedRocky，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/Rocky/CustomizedRocky/g&#x27; EFI/BOOT/grub.cfg</span><br><span class="line">sed -i &#x27;s/Rocky/CustomizedRocky/g&#x27; isolinux/grub.conf</span><br><span class="line">sed -i &#x27;s/Rocky/CustomizedRocky/g&#x27; isolinux/isolinux.cfg</span><br></pre></td></tr></table></figure>

<h2 id="封装-ISO"><a href="#封装-ISO" class="headerlink" title="封装 ISO"></a>封装 ISO</h2><p>完成修改后，重新封装 ISO, 命令如下，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">genisoimage -U -r -v -J -joliet-long -V &quot;CustomizedRocky-9-4-x86_64-dvd&quot; -volset &quot;CustomizedRocky-9-4-x86_64-dvd&quot; \</span><br><span class="line">	-A &quot;CustomizedRocky-9-4-x86_64-dvd&quot; -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 \</span><br><span class="line">	-boot-info-table -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \</span><br><span class="line">	-o /Rocky-9.4-x86_64-customized.iso .</span><br></pre></td></tr></table></figure>

<p>需要注意的是，确保命令中 -V, -volset 和 -A 选项的值与 ISO 里的引导加载程序配置匹配。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1、<a class="link"   href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/anaconda_customization_guide/sect-iso-images#sect-iso-images" >Working with ISO Images<i class="fas fa-external-link-alt"></i></a></p>
<p>2、<a class="link"   href="https://blog.k8s.li/rebuild-iso-image.html" >使用 overlay2 或 bind 重新构建 ISO 镜像<i class="fas fa-external-link-alt"></i></a> <strong>适用于 ISO CICD 方案的一种加速方案</strong></p>
]]></content>
      <tags>
        <tag>ISO</tag>
      </tags>
  </entry>
  <entry>
    <title>调试 libvirt 启动的 VM</title>
    <url>/debug-the-linux-kernel-libvirt.html</url>
    <content><![CDATA[<p>上篇，我们介绍了如何使用 qemu 启动内核并对其进行 debug。如今，很多云服务器都是通过 libvirt&#x2F;qemu 启动的。<br>本文就着手介绍，如何调试由 libvirt 启动的 linux 内核。</p>
<h2 id="xml-添加-s-参数"><a href="#xml-添加-s-参数" class="headerlink" title="xml 添加 -s 参数"></a>xml 添加 -s 参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;domain type=&#x27;kvm&#x27; xmlns:qemu=&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;&gt;</span><br><span class="line">  &lt;qemu:commandline&gt;</span><br><span class="line">    &lt;qemu:arg value=&#x27;-s&#x27;/&gt;</span><br><span class="line">  &lt;/qemu:commandline&gt;</span><br><span class="line">&lt;/domain&gt;</span><br></pre></td></tr></table></figure>
<p>添加 -s 参数后，qemu 会启动 1234 端口用来监听来自 gdb 的连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss -nltp | grep 1234</span></span><br><span class="line">LISTEN 0      1            0.0.0.0:1234       0.0.0.0:*    users:((&quot;qemu-kvm&quot;,pid=1273698,fd=107))</span><br><span class="line">LISTEN 0      1               [::]:1234          [::]:*    users:((&quot;qemu-kvm&quot;,pid=1273698,fd=108))</span><br></pre></td></tr></table></figure>

<h2 id="关闭内核地址空间随机化"><a href="#关闭内核地址空间随机化" class="headerlink" title="关闭内核地址空间随机化"></a>关闭内核地址空间随机化</h2><p>ASLR 是一个安全相关的特性，默认情况下，ASLR 是打开的。但是打开 ASLR 会导致我们 debug 过程中 gdb 无法命中断点。</p>
<p>因此，我们需要登录到 Guest 里通过向内核命令行添加 nokaslr 参数来关闭内核地址空间随机化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grubby --update-kernel=ALL --args=&quot;nokaslr&quot;</span><br></pre></td></tr></table></figure>

<p>修改完成后，重启机器(<code>reboot</code>)，重启后通过如下命令确认关闭成功，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cmdline | grep nokaslr</span><br></pre></td></tr></table></figure>

<h2 id="安装-debuginfo"><a href="#安装-debuginfo" class="headerlink" title="安装 debuginfo"></a>安装 debuginfo</h2><blockquote>
<p>假设我们的 guest 内核版本是 4.18.0-553.8.1.el8_10</p>
</blockquote>
<p>下载对应的 kernel-debuginfo 和 kernel-debuginfo-common 包, 并安装,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall kernel-debuginfo-4.18.0-553.8.1.el8_10.x86_64.rpm kernel-debuginfo-common-x86_64-4.18.0-553.8.1.el8_10.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h2 id="连接到-Guest"><a href="#连接到-Guest" class="headerlink" title="连接到 Guest"></a>连接到 Guest</h2><p>安装完 debuginfo 后，通过 gdb 连接到 Guest 即可开始 debug,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb /usr/lib/debug/lib/modules/4.18.0-553.8.1.el8_10.x86_64/vmlinux</span></span><br><span class="line"></span><br><span class="line">(gdb) target remote :1234</span><br><span class="line">(gdb) hbreak pick_next_task_fair</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>

<p><img   src="/../img/gdb-libvirt-pick-next-task-fair.png"  alt="set breakpoint at pick_next_task_fair"></p>
]]></content>
      <tags>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>PMEM 扩展系统内存用法介绍</title>
    <url>/extend-system-ram-using-pmem.html</url>
    <content><![CDATA[<p>在介绍 pmem 的几种用法之前，我们先来介绍 pmem 的几种模式，因为后面介绍的用法与 pmem 的这几种模式是分不开的。</p>
<h1 id="PMEM-的三种模式"><a href="#PMEM-的三种模式" class="headerlink" title="PMEM 的三种模式"></a>PMEM 的三种模式</h1><h2 id="1、Memory-Mode"><a href="#1、Memory-Mode" class="headerlink" title="1、Memory Mode"></a>1、Memory Mode</h2><p>pmem 配置为内存模式时，pmem 作为系统内存（system ram），原有的系统内存作为 cache。pmem 本身是比 DRAM 慢的，这种情况下，应用的访存延迟也会上升。内存模式屏蔽了本身的系统内存，针对虚拟化场景下一台物理机插了好几个内存的情况 几百G 的内存相当于被浪费了。</p>
<h2 id="2、App-Direct-Mode"><a href="#2、App-Direct-Mode" class="headerlink" title="2、App Direct Mode"></a>2、App Direct Mode</h2><p>pmem 配置为 AD 模式时，这种模式，pmem 作为一个额外的内存资源暴露给 OS。通常情况下，我们也是采用 AD 模式，然后将 pmem 配置为 system-ram ，这样针对 redis 这种大内存的场景提供了大内存的适中的解决方案，因为 pmem 比 DRAM 便宜不少，完全采用 DRAM 比较贵。</p>
<h2 id="3、Mixed-Mode"><a href="#3、Mixed-Mode" class="headerlink" title="3、Mixed Mode"></a>3、Mixed Mode</h2><p>用的少，混合模式的意思是，一部分配置为内存模式，剩下的容量自动为 AD 模式（配置内存模式时容量不配置为 100% 即代表混合模式）<br>pmem 提供了低成本大容量的内存解决方案。在 pmem 的三种模式的选择中，一般选择将 pmem 配置为 AD 模式来扩展系统内存，为 redis 等数据库场景提供更廉价的内存方案（相对来说，性能比完全采用 DRAM 会低一些）。</p>
<h1 id="PMEM-的用法"><a href="#PMEM-的用法" class="headerlink" title="PMEM 的用法"></a>PMEM 的用法</h1><h2 id="a-用作磁盘"><a href="#a-用作磁盘" class="headerlink" title="a) 用作磁盘"></a>a) 用作磁盘</h2><p>将原有的 NVME SSD盘换成 pmem，可以获得更高的IOPS和带宽、更低的延时，解决性能瓶颈问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ndctl create-namespace --region region0 --mode fsdax</span><br><span class="line"></span><br><span class="line">mkfs -t ext4 /dev/pmem0 &amp;&amp; \</span><br><span class="line">mkdir /mnt/sdb &amp;&amp; \</span><br><span class="line">mount -o dax,noatime /dev/pmem0 /mnt/sdb</span><br></pre></td></tr></table></figure>
<p>执行 <code>df -h</code> 查看刚刚挂载的磁盘。</p>
<h2 id="b-用作-ram（DRAM-作为-cache）"><a href="#b-用作-ram（DRAM-作为-cache）" class="headerlink" title="b) 用作 ram（DRAM 作为 cache）"></a>b) 用作 ram（DRAM 作为 cache）</h2><p>将 pmem 当做一个系统内存来使用，原有的系统内存会看做一层 cache。这种用法下， pmem 是易失的，和 DRAM 的易失特性一样。这种用法，唯一的感觉是比较浪费，系统原有的内存被当做 cache 了，没有得到好的运用。</p>
<h2 id="c-用作-numa-node"><a href="#c-用作-numa-node" class="headerlink" title="c) 用作 numa node"></a>c) 用作 numa node</h2><p>pmem 的另一个种用法是当做一个 numa node。当机器上被插上几根 pmem 内存时，pmem 内存会被识别为 numa 节点（配置方式如下），相较于 用作 ram 的方式，优点是显而易见的，扩展了系统可用内存。原有的系统内存也不会对上层屏蔽掉，依然可以被上层应用使用。</p>
<p>现在的数据中心级别的服务器操作系统通常都会配置大页来获得更好的性能。通常的大页配置为 2M 大页和 1G 大页。这里我们也介绍在 pmem 所在的 numa node 开启大页。</p>
<h3 id="开启-2M-大页"><a href="#开启-2M-大页" class="headerlink" title="开启 2M 大页"></a>开启 2M 大页</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daxctl migrate-device-model</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 namespace</span></span><br><span class="line">ndctl create-namespace --region=region0 --mode=devdax</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 dax 设陪配置为 system-ram 模式</span></span><br><span class="line">daxctl reconfigure-device dax0.0 --mode=system-ram</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分配 1024 个 2M 大页</span></span><br><span class="line">echo 1024 &gt; /sys/devices/system/node/node2/hugepages/hugepages-2048kB/nr_hugepages</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 2M 页分配结果</span></span><br><span class="line">cat /sys/devices/system/node/node2/hugepages/hugepages-2048kB/nr_hugepages</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>
<p><code>cat nr_hugepages</code> 返回值可以看到，成功开启了 1024 个 hugepage。<br>注：dax 设备默认的对齐就是 2M，所以 <code>ndctl create-namespace</code>  可以省略掉对齐参数。</p>
<h3 id="开启-1G-大页"><a href="#开启-1G-大页" class="headerlink" title="开启 1G 大页"></a>开启 1G 大页</h3><p>我们按照下面的方式开启 1G 大页，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daxctl migrate-device-model</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照 1G 对齐</span></span><br><span class="line">ndctl create-namespace --region=region0 --align 1g --mode=devdax </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 dax 设陪配置为 system-ram 模式</span></span><br><span class="line">daxctl reconfigure-device dax0.0 --mode=system-ram </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分配 248 个 1G 内存页</span></span><br><span class="line">echo 248 &gt; /sys/devices/system/node/node2/hugepages/hugepages-1048576kB/nr_hugepages</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 1G 页分配结果</span></span><br><span class="line">cat /sys/devices/system/node/node2/hugepages/hugepages-1048576kB/nr_hugepages</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>1G 页分配失败了，原因往下看，一句话概括是 kernel 拒绝将 1G 页面放到 ZONE_MOVABLE 里进行管理。</p>
<h3 id="为什么同样的方式不能开启-1G-大页？"><a href="#为什么同样的方式不能开启-1G-大页？" class="headerlink" title="为什么同样的方式不能开启 1G 大页？"></a>为什么同样的方式不能开启 1G 大页？</h3><p>这里先介绍一个背景，linux 里大页通常由两种，一种是 2M 大页，另一种是 1G 大页。1G 大页在理论上是可以迁移的，但是实际上是不可以迁移的。<br>不可迁移的原因是，当系统运行了一段时间后，系统内存已经碎了，很难找到一个空闲的 1G 大页将内存页里的数据搬运过去。因此，内核认为 1G 大页是不可以迁移的，不把 1G 大页放在 ZONE_MOVABLE 里进行管理。这也是造成照葫芦画瓢失败的原因。</p>
<h3 id="如何在-PMEM-上分配-1G-大页？"><a href="#如何在-PMEM-上分配-1G-大页？" class="headerlink" title="如何在 PMEM 上分配 1G 大页？"></a>如何在 PMEM 上分配 1G 大页？</h3><p>当前操作系统（RHEL Family）环境下，很多因素会导致 pmem 会被自动 online 到 ZONE_MOVABLE。这也是我们为什么按照 2M 页方式开启 1G 页的方式失败的原因。</p>
<p>可能得原因有，daxtctl 工具本身，system udev 规则 或者 auto_online_blocks 。这三个因素，每一个都有可能导致 pmem online 到 ZONE_MOVABLE 上，进而导致分配失败</p>
<h4 id="1、禁用-auto-online-blocks"><a href="#1、禁用-auto-online-blocks" class="headerlink" title="1、禁用 auto_online_blocks"></a>1、禁用 auto_online_blocks</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/memory/auto_online_blocks</span><br><span class="line">offline</span><br></pre></td></tr></table></figure>
<h4 id="2、修改系统-udev-规则"><a href="#2、修改系统-udev-规则" class="headerlink" title="2、修改系统 udev 规则"></a>2、修改系统 udev 规则</h4><p>注释掉 Memory hotadd request 部分</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/udev/rules.d/40-redhat.rules</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Memory hotadd request</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SUBSYSTEM!=<span class="string">&quot;memory&quot;</span>, GOTO=<span class="string">&quot;memory_hotplug_end&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ACTION!=<span class="string">&quot;add&quot;</span>, GOTO=<span class="string">&quot;memory_hotplug_end&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONST&#123;<span class="built_in">arch</span>&#125;==<span class="string">&quot;s390*&quot;</span>, GOTO=<span class="string">&quot;memory_hotplug_end&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONST&#123;<span class="built_in">arch</span>&#125;==<span class="string">&quot;ppc64*&quot;</span>, GOTO=<span class="string">&quot;memory_hotplug_end&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ENV&#123;.state&#125;=<span class="string">&quot;online&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONST&#123;virt&#125;==<span class="string">&quot;none&quot;</span>, ENV&#123;.state&#125;=<span class="string">&quot;online_movable&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ATTR&#123;state&#125;==<span class="string">&quot;offline&quot;</span>, ATTR&#123;state&#125;=<span class="string">&quot;<span class="variable">$env</span>&#123;.state&#125;&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LABEL=<span class="string">&quot;memory_hotplug_end&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3、daxctl-配置-ZONE-MOVABLE"><a href="#3、daxctl-配置-ZONE-MOVABLE" class="headerlink" title="3、daxctl 配置 !ZONE_MOVABLE"></a>3、daxctl 配置 !ZONE_MOVABLE</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daxctl reconfigure-device dax0.0 --mode=system-ram --no-movable</span><br></pre></td></tr></table></figure>

<p>经过上诉几个步骤，现在可以正常开启 1G 大页了。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>1、man daxctl reconfigure-device movable<br>2、<a class="link"   href="https://docs.kernel.org/admin-guide/mm/memory-hotplug.html#zone-movable:~:text=Gigantic%20pages%20are%20unmovable" >Memory Hot(Un)Plug Docs in Linux Kernel<i class="fas fa-external-link-alt"></i></a><br>3、<a class="link"   href="https://mp.weixin.qq.com/s/RLU1f-7ckETrQhl7mZigyQ" >Linux Kernel中AEP的现状和发展<i class="fas fa-external-link-alt"></i></a><br>4、<a class="link"   href="https://stevescargall.com/2019/07/09/how-to-extend-volatile-system-memory-ram-using-persistent-memory-on-linux/" >How To Extend Volatile System Memory (RAM) using Persistent Memory on Linux – Steve Scargall<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>pmem</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Next主题配置</title>
    <url>/hexo-next-theme-configuration-picture-configuration.html</url>
    <content><![CDATA[<h1 id="一、图片配置"><a href="#一、图片配置" class="headerlink" title="一、图片配置"></a>一、图片配置</h1><p>hexo 本地引入图片无法被markdown渲染，导致本地看不见，云端经过hexo 渲染后看得见。其实就是个路径问题。</p>
<p><strong>修改引入图片路径即可解决，</strong></p>
<p>我们只需要在 <code>_posts</code> 的同级目录下新建一个 <code>img</code> 文件夹专门用来存放所有的图片，markdown里面引用使用相对格式</p>
<p><code>../img/gris.png</code> (后面有效果展示)。其实非常简单，引用的时候加两个点即可，这样本地和云端都可以正常预览&#x2F;显示图片，<strong>但是文件名不要有空格</strong>，有空格云端显示不出来。</p>
<p><img   src="/../img/gris.png"  alt="Gris"></p>
<p><strong>结构展示</strong></p>
<p>如果没有理解的话，看看这张结构图</p>
<p><img   src="/../img/dict_tree.png" ></p>
<h1 id="二、插件"><a href="#二、插件" class="headerlink" title="二、插件"></a>二、插件</h1><p>安装插件的时候要多搜索，寻找最近的文章看，如果你也是使用Next 主题，尽量找Hexo Next 官方最近更新的文档看，因为随着<code>Hexo/Next</code>的版本更新，很多功能都被开发者集成进去了，只需要修改一下主题配置文件即可，<strong>简而言之，找最新的文章&#x2F;文档参考。</strong></p>
<blockquote>
<p>Hexo-Next 文档地址</p>
<p>Hexo-Next: <a class="link"   href="https://hexo-next.readthedocs.io/zh_CN/latest" >https://hexo-next.readthedocs.io/zh_CN/latest<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="安装的插件"><a href="#安装的插件" class="headerlink" title="安装的插件"></a>安装的插件</h2><p>安装的插件并不多，主要是够用即可</p>
<p>hexo-symbols-count-time</p>
<p>hexo-excerpt —— Because, auto_excerpt not working</p>
<p>hexo-generator-searchdb——站内搜索</p>
<p>大家都喜欢的插件，Next 文档都已经列出来了，去找就行了🤣</p>
<blockquote>
<p>Hexo-Next: <a class="link"   href="https://hexo-next.readthedocs.io/zh_CN/latest" >https://hexo-next.readthedocs.io/zh_CN/latest<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p><img   src="/../img/Next_dos_advanced.png" ></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为 RPM 包签名</title>
    <url>/how-to-sign-rpm-package.html</url>
    <content><![CDATA[<h2 id="Generate-GPG-keyring"><a href="#Generate-GPG-keyring" class="headerlink" title="Generate GPG keyring"></a>Generate GPG keyring</h2><p>使用下面的命令生成 GPG keyring。输入 Name 和 Email 。输入 o 确认后，passphrase 可以不输入（保留为空即可），passphrase 保留为空代表不需要密码保护（公钥和私钥需要确认两次）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure>

<p>查看生成的 GPG key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg -K</span><br></pre></td></tr></table></figure>

<h2 id="rpmsign"><a href="#rpmsign" class="headerlink" title="rpmsign"></a>rpmsign</h2><p>导出公钥，生成一个公钥文件，此公钥文件通常根据用途不同放到 repo 源中，或者直接导入系统用于安装 RPM 时进行 GPG 验证。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --armor --<span class="built_in">export</span> &gt; RPM-GPG-KEY-EXAMPLE</span><br></pre></td></tr></table></figure>

<p>将所有的 RPM 包进行签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmsign --define <span class="string">&quot;_gpg_name security@example.com&quot;</span> --addsign *.rpm</span><br></pre></td></tr></table></figure>

<h2 id="migrate-GPG-keyring"><a href="#migrate-GPG-keyring" class="headerlink" title="migrate GPG keyring"></a>migrate GPG keyring</h2><p>1、export GPG keyring</p>
<p>-a, –armor, 以 ascii 方式导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># export public key</span></span><br><span class="line">gpg -a --<span class="built_in">export</span> &gt;mypubkeys.asc</span><br><span class="line"><span class="comment"># export private key</span></span><br><span class="line">gpg -a --export-secret-keys &gt;myprivatekeys.asc</span><br></pre></td></tr></table></figure>

<p>2、export GPG trustdb (Optionally)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># export gpg&#x27;s trustdb (Optionally)</span></span><br><span class="line">gpg --export-ownertrust &gt;mytrustdb.txt</span><br></pre></td></tr></table></figure>

<p>3、import GPG keyring</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --import myprivatekeys.asc</span><br><span class="line">gpg --import mypubkeys.asc</span><br><span class="line"></span><br><span class="line"><span class="comment"># list public &amp; secret keys</span></span><br><span class="line">gpg -K</span><br><span class="line">gpg -k</span><br></pre></td></tr></table></figure>

<p>4、import trustdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --import-ownertrust mytrustdb.txt</span><br></pre></td></tr></table></figure>

<p>当我们导入 GPG keyrings 时，GPG 并不信任 keyrings，需要导入 trustdb 后，并更新下 trustdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --update-trustdb</span><br></pre></td></tr></table></figure>

<p>5、force trust GPG keyring</p>
<p>如果没有导入 trustdb，GPG 认为 keys 不可信。可以使用下面的命令信任所有的 GPG keyrings。</p>
<p>注意，只信任自己创建的 keyring，不要信任互联网的其他 keyring。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --list-keys --fingerprint |grep pub -A 1|egrep -Ev <span class="string">&quot;pub|--&quot;</span>|<span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span> \</span><br><span class="line"> | awk <span class="string">&#x27;BEGIN &#123; FS = &quot;\n&quot; &#125; ; &#123; print $1&quot;:6:&quot; &#125; &#x27;</span> | gpg --import-ownertrust</span><br></pre></td></tr></table></figure>

<h2 id="搭配-OBS-使用"><a href="#搭配-OBS-使用" class="headerlink" title="搭配 OBS 使用"></a>搭配 OBS 使用</h2><p>OBS(Open Build Service) 是一个可以用于为各个发行版打包的编译系统。OBS 系统默认会使用自己生成的签名，但是如果能让 OBS 系统使用我们自己的签名不是很好，接下来就介绍如何让 OBS 使用我们的 GPG Keyring 为 RPM 包进行签名。</p>
<p>平时我们使用 rpmbuild 命令在虚拟机或者 docker 中打包的时候签名的公钥都是存放在 <code>~/.gnupg</code> 目录下，这也是 gpg -k 等命令的默认搜索路径，但是 OBS 是一个单独的系统，他的配置都放在单独的 <code>/srv</code> 目录下。rpmsign 使用的公钥的存放目录是 <code>/srv/obs/gnupg</code>。</p>
<p>因此，只需要在导入 GPG Keyring 时候，通过 <code>--homedir</code> 指定目录即可，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --import  my-publickey.asc</span><br><span class="line">gpg --import my-privatekey.asc</span><br><span class="line">gpg --import-ownertrust my-gpgtrustdb.txt</span><br></pre></td></tr></table></figure>


<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="为什么需要迁移-GPG-keyring"><a href="#为什么需要迁移-GPG-keyring" class="headerlink" title="为什么需要迁移 GPG keyring"></a>为什么需要迁移 GPG keyring</h3><p>进行 RPM 打包的时候，都会给 RPM 包签名。同一个发行商都会给 RPM 包签名，不同的 build system，比如 OBS（open build service），Koji 等都可以实现自动签名。我们可以导入 GPG keyring，而不是让构建系统自己生成一个。</p>
<h3 id="为什么需要导入-trustdb？"><a href="#为什么需要导入-trustdb？" class="headerlink" title="为什么需要导入 trustdb？"></a>为什么需要导入 trustdb？</h3><p>如果不导入 trustdb，当导入迁移后的 GPG keyring 时，GPG keyring 状态变为 unknown。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# gpg -K</span><br><span class="line">/root/.gnupg/pubring.kbx</span><br><span class="line">------------------------</span><br><span class="line">sec   rsa3072 2022-11-02 [SC] [expires: 2024-11-01]</span><br><span class="line">      024B8C9501E35519D203B3B6DCD37021E3793FD6</span><br><span class="line">uid           [ultimate] security &lt;@example.com&gt;</span><br><span class="line">ssb   rsa3072 2022-11-02 [E] [expires: 2024-11-01]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# gpg -K</span><br><span class="line">/root/.gnupg/pubring.kbx</span><br><span class="line">------------------------</span><br><span class="line">sec   rsa3072 2022-11-02 [SC] [expires: 2024-11-01]</span><br><span class="line">      024B8C9501E35519D203B3B6DCD37021E3793FD6</span><br><span class="line">uid           [unknown] security &lt;@example.com&gt;</span><br><span class="line">ssb   rsa3072 2022-11-02 [E] [expires: 2024-11-01]</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、<a class="link"   href="https://access.redhat.com/solutions/2115511" >https://access.redhat.com/solutions/2115511<i class="fas fa-external-link-alt"></i></a></p>
<p>2、<a class="link"   href="https://docs.pagure.org/koji/signing/" >https://docs.pagure.org/koji/signing/<i class="fas fa-external-link-alt"></i></a></p>
<p>3、<a class="link"   href="https://unix.stackexchange.com/questions/639514/unknown-validity-despite-having-signed-the-key-myself" >https://unix.stackexchange.com/questions/639514/unknown-validity-despite-having-signed-the-key-myself<i class="fas fa-external-link-alt"></i></a></p>
<p>4、<a class="link"   href="https://stackoverflow.com/questions/53886734/how-to-trust-a-bunch-of-public-pgp-keys-you-trust-without-doing-it-manually" >https://stackoverflow.com/questions/53886734/how-to-trust-a-bunch-of-public-pgp-keys-you-trust-without-doing-it-manually<i class="fas fa-external-link-alt"></i></a></p>
<p>5、<a class="link"   href="https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration.html" >https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration.html<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>查询 Intel 处理器安全漏洞</title>
    <url>/intel-cpu-cve.html</url>
    <content><![CDATA[<h2 id="Intel-处理器安全漏洞表"><a href="#Intel-处理器安全漏洞表" class="headerlink" title="Intel 处理器安全漏洞表"></a>Intel 处理器安全漏洞表</h2><p><a class="link"   href="https://www.intel.com/content/www/us/en/developer/topic-technology/software-security-guidance/processors-affected-consolidated-product-cpu-model.html" >https://www.intel.com/content/www/us/en/developer/topic-technology/software-security-guidance/processors-affected-consolidated-product-cpu-model.html<i class="fas fa-external-link-alt"></i></a></p>
<p><img   src="/../img/1701078889956-2908e693-214c-4762-9897-53c5924ec88c.png"  alt="image.png"></p>
<h2 id="处理器安全漏洞只需要关注这两个方面"><a href="#处理器安全漏洞只需要关注这两个方面" class="headerlink" title="处理器安全漏洞只需要关注这两个方面"></a>处理器安全漏洞只需要关注这两个方面</h2><p>Intel 处理器的漏洞表，包含了所有漏洞，每个漏洞一列（图中右上角），漏洞描述包含 CVE 名称，编号以及 Intel 的编号。新披露的漏洞靠左，老披露的靠右。</p>
<p>1、我用的是哪一款 CPU？<br>通过 <code>Family</code>、<code>Model</code> 、<code>Stepping</code> 三项就可以定位到列表中的特定型号所在行（<strong>图中左上角</strong>），查看 CPU 型号通过 lscpu 命令。<br>2、我是否受到此次 CVE 的影响？<br>观察<strong>图中右下角</strong>的字段，</p>
<ul>
<li>Not Affected: 代表不受影响</li>
<li>MCU：代表需要更新微码</li>
<li>Software：代表需要升级软件</li>
</ul>
<h2 id="如何查看我的-CPU-的型号？"><a href="#如何查看我的-CPU-的型号？" class="headerlink" title="如何查看我的 CPU 的型号？"></a>如何查看我的 CPU 的型号？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lscpu | grep -E <span class="string">&quot;CPU family:|Model:|Stepping:&quot;</span></span></span><br><span class="line">CPU family:          6</span><br><span class="line">Model:               85</span><br><span class="line">Stepping:            4</span><br></pre></td></tr></table></figure>
<p>其中 Model 输出结果都是 10 进制，Intel 处理器漏洞表面里使用的是 16 进制（后缀是 H，代表是 16 进制），85 的 16 进制表示 55H，所以这款 CPU 的 Family_Model 是 06_55H, Steeping 是 4。</p>
]]></content>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>kubeadm 公网环境搭建 kubenetes 集群</title>
    <url>/kubeadm-setup-kubernetes-cluster-public-network.html</url>
    <content><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>前段时间云厂商双 11 打折，没忍住剁手了两台云服务器。准备搭建一个公网环境下的 Kubenetes 集群。</p>
<table>
<thead>
<tr>
<th>厂商</th>
<th>配置</th>
<th>k8s用途</th>
</tr>
</thead>
<tbody><tr>
<td>阿里云</td>
<td>2c2g</td>
<td>node</td>
</tr>
<tr>
<td>京东云</td>
<td>2c4g</td>
<td>master</td>
</tr>
</tbody></table>
<h1 id="配置云服务器"><a href="#配置云服务器" class="headerlink" title="配置云服务器"></a>配置云服务器</h1><h2 id="配置公网-IP"><a href="#配置公网-IP" class="headerlink" title="配置公网 IP"></a>配置公网 IP</h2><p>云厂商的 ECS 都有分配一个公网 IP。这个公网 IP 在控制台上会显示，但是 IP 并不是直接配置在 ECS 机器上。</p>
<p>在机器上通过 <code>ip a</code> 命令只能看到内网 IP，我们需要在 ECS 设置一个虚拟网卡，将控制台的公网 IP 配置在 ECS 上。</p>
<p> 将公网 IP 配置到 eth0 网卡上，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 x.x.x.x 替换为机器公网IP</span></span><br><span class="line">ip addr add x.x.x.x/24 dev eth0 label eth0:0</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0:0 up</span><br></pre></td></tr></table></figure>

<p>命令含义是为 eth0 网卡设置一个别名，eth0:0，将 ip 配置在这个别名上。</p>
<p>添加完成后，可以看到如下 eth0 下面多了 ipv4 的 IP。</p>
<p><img   src="/../img/kubeadm-setup-kubernetes-cluster-public-network-assign-public-ip.png"  alt="Assign Public IP to eth0"></p>
<blockquote>
<p>Tips如果 IP 配置错了，等价删除命令 <code>ip addr del x.x.x.x/24 dev eth0:0</code></p>
</blockquote>
<h2 id="放行端口"><a href="#放行端口" class="headerlink" title="放行端口"></a>放行端口</h2><p>云服务器很多端口默认关闭的，需要在控制台打开</p>
<table>
<thead>
<tr>
<th>端口号</th>
<th>组件</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>6443</td>
<td>apiserver</td>
<td>放行 master apiserver 端口</td>
</tr>
</tbody></table>
<p>端口是否开放可以通过 <code>telnet [IP] [端口]</code> 的方式测试，</p>
<p><img   src="/../img/kubeadm-setup-kubernetes-cluster-public-network-telnet.png"  alt="Test Port Open via Telnet"></p>
<p>关闭 firewalld</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>

<h1 id="安装-containerd"><a href="#安装-containerd" class="headerlink" title="安装 containerd"></a>安装 containerd</h1><p>安装 containerd 并生成默认配置，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置源</span></span><br><span class="line">dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y containerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成默认配置</span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改pause镜像为阿里云镜像地址</span></span><br><span class="line">sed -i <span class="string">&#x27;s|registry.k8s.io/pause|registry.aliyuncs.com/google_containers/pause|&#x27;</span> /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure>

<h1 id="安装-kubenetes"><a href="#安装-kubenetes" class="headerlink" title="安装 kubenetes"></a>安装 kubenetes</h1><p>安装 kubenetes 1.28，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 kubenetes 源</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.tuna.tsinghua.edu.cn/kubernetes/core:/stable:/v1.28/rpm/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.28/rpm/repodata/repomd.xml.key</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<p><strong>如何安装其他版本 kubenetes?</strong></p>
<p>因为 kubenetes 仓库源变更过仓库结构，目前的仓库结构，k8s 是按照版本分开在不同目录里。针对比较老的 k8s 版本，需要使用 <a class="link"   href="https://mirrors.aliyun.com/kubernetes" >https://mirrors.aliyun.com/kubernetes<i class="fas fa-external-link-alt"></i></a> 源</p>
<p>安装 kubenetes 1.18，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置源</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes-old.repo</span></span><br><span class="line"><span class="string">[kubernetes-old]</span></span><br><span class="line"><span class="string">name=Kubernetes old</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install kubeadm-1.18.0-0 kubelet-1.18.0-0 kubectl-1.18.0-0</span><br></pre></td></tr></table></figure>

<h1 id="安装-crictl"><a href="#安装-crictl" class="headerlink" title="安装 crictl"></a>安装 crictl</h1><p>crictl 是一个很方便的工具。在安装 kubenetes 时候应该已经安装完成 crictl。如果没有安装，通过 <code>yum install cri-tools</code>安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/crictl.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">runtime-endpoint: unix:///run/containerd/containerd.sock</span></span><br><span class="line"><span class="string">image-endpoint: unix:///run/containerd/containerd.sock</span></span><br><span class="line"><span class="string">timeout: 2</span></span><br><span class="line"><span class="string">debug: false</span></span><br><span class="line"><span class="string">pull-image-on-create: false</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h1 id="kubenetes-部署"><a href="#kubenetes-部署" class="headerlink" title="kubenetes 部署"></a>kubenetes 部署</h1><p>从现在开始，部署 k8s 集群正式开始，</p>
<h2 id="提前拉取镜像"><a href="#提前拉取镜像" class="headerlink" title="提前拉取镜像"></a>提前拉取镜像</h2><p>先将 kubeadm 所需要的组件镜像提前拉取下来，使用阿里云镜像仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>

<h2 id="生成-init-配置"><a href="#生成-init-配置" class="headerlink" title="生成 init 配置"></a>生成 init 配置</h2><p>这里使用的是直接配置 yaml 的方式来部署集群，没有采用命令行，原因有两点，</p>
<p>1、命令行参数经常会变化，针对新手用户，如果命令出错了，不知道从哪里下手排查</p>
<p>2、通过配置 yaml 的方式，能加深对 kubenetes 组件的理解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm-init.yaml</span><br></pre></td></tr></table></figure>

<p>修改 init 配置，主要修改地方有 4 处，设置公网 IP，设置主机名，修改阿里云镜像源，新增一个 podSubnet 的条目，这里在后面的 CNI 网络要用到。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: kubeadm.<span class="property">k8s</span>.<span class="property">io</span>/v1beta3</span><br><span class="line"><span class="attr">bootstrapTokens</span>:</span><br><span class="line">- <span class="attr">groups</span>:</span><br><span class="line">  - <span class="attr">system</span>:<span class="attr">bootstrappers</span>:<span class="attr">kubeadm</span>:<span class="keyword">default</span>-node-token</span><br><span class="line">  <span class="attr">token</span>: abcdef.0123456789abcdef</span><br><span class="line">  <span class="attr">ttl</span>: 24h0m0s</span><br><span class="line">  <span class="attr">usages</span>:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint</span>:</span><br><span class="line">  <span class="attr">advertiseAddress</span>: <span class="number">117.72</span><span class="number">.114</span><span class="number">.94</span> # 修改为master公网ip</span><br><span class="line">  <span class="attr">bindPort</span>: <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration</span>:</span><br><span class="line">  <span class="attr">criSocket</span>: <span class="attr">unix</span>:<span class="comment">///var/run/containerd/containerd.sock</span></span><br><span class="line">  <span class="attr">imagePullPolicy</span>: <span class="title class_">IfNotPresent</span></span><br><span class="line">  <span class="attr">name</span>: k8s-master # 修改为主机名</span><br><span class="line">  <span class="attr">taints</span>: <span class="literal">null</span></span><br><span class="line">---</span><br><span class="line"><span class="attr">apiServer</span>:</span><br><span class="line">  <span class="attr">timeoutForControlPlane</span>: 4m0s</span><br><span class="line"><span class="attr">apiVersion</span>: kubeadm.<span class="property">k8s</span>.<span class="property">io</span>/v1beta3</span><br><span class="line"><span class="attr">certificatesDir</span>: <span class="regexp">/etc/</span>kubernetes/pki</span><br><span class="line"><span class="attr">clusterName</span>: kubernetes</span><br><span class="line"><span class="attr">controllerManager</span>: &#123;&#125;</span><br><span class="line"><span class="attr">dns</span>: &#123;&#125;</span><br><span class="line"><span class="attr">etcd</span>:</span><br><span class="line">  <span class="attr">local</span>:</span><br><span class="line">    <span class="attr">dataDir</span>: <span class="regexp">/var/</span>lib/etcd</span><br><span class="line"><span class="attr">imageRepository</span>: registry.<span class="property">aliyuncs</span>.<span class="property">com</span>/google_containers # 修改国内镜像源</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion</span>: <span class="number">1.28</span><span class="number">.0</span></span><br><span class="line"><span class="attr">networking</span>:</span><br><span class="line">  <span class="attr">dnsDomain</span>: cluster.<span class="property">local</span></span><br><span class="line">  <span class="attr">serviceSubnet</span>: <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">12</span></span><br><span class="line">  <span class="attr">podSubnet</span>: <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> # 新增-指定<span class="variable constant_">CNI</span>使用的网段</span><br><span class="line"><span class="attr">scheduler</span>: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h2><p>修改好配置后，初始化集群</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">kubeadm init --config kubeadm-init.<span class="property">yaml</span> --v <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>集群初始化完成后，将这条命令保存到 <code>～/.bashrc</code> 中，方便后续通过 kubectl 命令管理集群。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="variable constant_">KUBECONFIG</span>=<span class="regexp">/etc/</span>kubernetes/admin.<span class="property">conf</span></span><br></pre></td></tr></table></figure>

<p>执行完这一步，集群所需的关里面组件已经 up，此时集群依然是 not-ready 状态，应为我们还差集群网络没有配置，配置完毕后，集群状态会变为 ready。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods -A</span><br><span class="line"><span class="variable constant_">NAMESPACE</span>     <span class="variable constant_">NAME</span>                                 <span class="variable constant_">READY</span>   <span class="variable constant_">STATUS</span>    <span class="variable constant_">RESTARTS</span>   <span class="variable constant_">AGE</span></span><br><span class="line">kube-system   etcd-k8s-master                      <span class="number">1</span>/<span class="number">1</span>     <span class="title class_">Running</span>   <span class="number">9</span>          14s</span><br><span class="line">kube-system   kube-apiserver-k8s-master            <span class="number">1</span>/<span class="number">1</span>     <span class="title class_">Running</span>   <span class="number">9</span>          12s</span><br><span class="line">kube-system   kube-controller-manager-k8s-master   <span class="number">1</span>/<span class="number">1</span>     <span class="title class_">Running</span>   <span class="number">11</span>         12s</span><br><span class="line">kube-system   kube-scheduler-k8s-master            <span class="number">1</span>/<span class="number">1</span>     <span class="title class_">Running</span>   <span class="number">10</span>         12s</span><br></pre></td></tr></table></figure>

<h2 id="集群网络配置-flannel"><a href="#集群网络配置-flannel" class="headerlink" title="集群网络配置 flannel"></a>集群网络配置 flannel</h2><p>使用 flannel 0.26.2 作为集群的网络方案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载 flannel 配置</span></span><br><span class="line">wget https://github.com/flannel-io/flannel/releases/download/v0.26.2/kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前下载 flannel 所需镜像，使用 daocloud 源</span></span><br><span class="line"><span class="comment"># 不同版本 flannel 采用的镜像版本不同，镜像版本查看 kube-flannel.yml 文件即可</span></span><br><span class="line">crictl pull m.daocloud.io/docker.io/flannel/flannel:v0.26.2</span><br><span class="line">crictl pull m.daocloud.io/docker.io/flannel/flannel-cni-plugin:v1.6.0-flannel1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换镜像地址</span></span><br><span class="line">sed -i <span class="string">&#x27;s|docker.io|m.daocloud.io/docker.io|&#x27;</span> kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure>

<h2 id="Node-节点加入集群"><a href="#Node-节点加入集群" class="headerlink" title="Node 节点加入集群"></a>Node 节点加入集群</h2><p>kubeadm 创建集群完成后，会升成一条 join 命令用于节点加入集群，如果这条命令没保存也没有关系。让 master 重新生成一个 token 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubeadm token create --print-join-command</span><br><span class="line">kubeadm <span class="built_in">join</span> x.x.x.x:6443 --token jpqqsk.ion4kc134qm2z8zv --discovery-token-ca-cert-hash sha256:f40dadc8070ff0218bcfe8530974937a95e3cd1e2d25cd5f865669ac3b40bdb1</span><br></pre></td></tr></table></figure>

<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h3 id="如何-debug-flannel-启动失败问题？"><a href="#如何-debug-flannel-启动失败问题？" class="headerlink" title="如何 debug flannel 启动失败问题？"></a>如何 debug flannel 启动失败问题？</h3><p>当集群 apiserver 正常时，通过查看 flannel pod 的 日志确认错误</p>
<p><code>kubectl logs kube-flannel-ds-xxxxx -n kube-flannel</code></p>
<p><img   src="/../img/kubeadm-setup-kubernetes-cluster-public-network-flannel-logs.png"  alt="Debug flannel with pod logs"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1、<a class="link"   href="https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md" >https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md<i class="fas fa-external-link-alt"></i></a></p>
<p>2、<a class="link"   href="https://juejin.cn/post/7383894854152405043" >https://juejin.cn/post/7383894854152405043<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>kubenetes</category>
      </categories>
      <tags>
        <tag>kubeadm</tag>
        <tag>cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>PARSEC 3.0 编译报错</title>
    <url>/parsec3.0-compile-error.html</url>
    <content><![CDATA[<p>PARSEC 3.0(Parallel Applications Research for System Efficiency Collectio)是一个基准测试套件，用于评估多核处理器和系统的性能，也就是跑分软件。</p>
<p>工作中需要使用到这个软件作为基准测试软件，因为 PARSEC 从官网下载下来是不能直接运行的，所以有了下面适配 RHEL 9 操作系统的内容。<br>文章末尾有所有修改的 patches 文件，里面记录详细的修改地方。</p>
<h1 id="安装-PARSEC-3-0"><a href="#安装-PARSEC-3-0" class="headerlink" title="安装 PARSEC 3.0"></a>安装 PARSEC 3.0</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Full PARSEC 3.0 tarball</span></span><br><span class="line">wget http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz</span><br><span class="line"></span><br><span class="line">tar xvf parsec-3.0.tar.gz</span><br><span class="line">cd parsec-3.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">source env.sh</span><br><span class="line">parsecmgmt -a build</span><br></pre></td></tr></table></figure>

<h1 id="编译错误合集"><a href="#编译错误合集" class="headerlink" title="编译错误合集"></a>编译错误合集</h1><h2 id="error-ISO-C-17-does-not-allow-dynamic-exception-specifications"><a href="#error-ISO-C-17-does-not-allow-dynamic-exception-specifications" class="headerlink" title="error: ISO C++17 does not allow dynamic exception specifications"></a>error: ISO C++17 does not allow dynamic exception specifications</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.h:62:24: error: ISO C++17 does not allow dynamic exception specifications</span><br><span class="line">   62 |     Thread(Runnable &amp;) throw(ThreadCreationException);</span><br></pre></td></tr></table></figure>
<p>在 C++17 标准中，将动态异常规范（Dynamic Exception Specification）声明为废弃（deprecated），也就是不推荐使用。在 RHEL 9 操作系统上默认的 C++ 标准是 17。所以会遇到这个编译报错，我们只需要使用老版本的 C++ 标准来编译代码可以规避这个问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config/gcc.bldconf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Arguments to use</span></span><br><span class="line">export CFLAGS=&quot; -O3 -g -funroll-loops -fprefetch-loop-arrays -std=gnu11 $&#123;PORTABILITY_FLAGS&#125;&quot;</span><br><span class="line">export CXXFLAGS=&quot;-O3 -g -funroll-loops -fprefetch-loop-arrays -fpermissive -fno-exceptions -std=gnu++11 $&#123;PORTABILITY_FLAGS&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>在 gcc.bldconf 里指明让 gcc 使用 gnu11&#x2F;gnu++11 标准编译代码。</p>
<p>这里没有使用 c11、c++11 标准而是使用 gnu 版本实现的 C、C++  标准。<br>如果使用 c11&#x2F;c++11 标准，会遇到这个报错 <code>warning: implicit declaration of function &#39;strdup&#39;</code> gcc 编译器会申明 这个宏—— “<strong>STRICT_ANSI</strong>“，代表只使用 c11、 spec 里的标准 C 库。这会导致我们经常使用的一些像 strdup 这些库函数不能使用（parsec3 用到了这些库函数）</p>
<h2 id="error-looser-exception-specification-on-overriding-virtual-function"><a href="#error-looser-exception-specification-on-overriding-virtual-function" class="headerlink" title="error: looser exception specification on overriding virtual function"></a>error: looser exception specification on overriding virtual function</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">WorkerGroup.h:88:5: error: looser exception specification on overriding virtual function &#x27;virtual threads::WorkerGroup::~WorkerGroup() throw (threads::CondException, threads::MutexException)&#x27;</span><br><span class="line">   88 |     ~WorkerGroup();</span><br></pre></td></tr></table></figure>
<p>这个错误意思是子类 override 父类的虚函数时候，子类的异常规范比父类更宽松（looser），也就是说子类的异常规范允许抛出更多类型的异常，这与 C++ 的异常规范要求相违背。所以，我们要让子类的异常更严格，而不是更宽容。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// WorkerGroup.h</span><br><span class="line"><span class="deletion">-    ~WorkerGroup();</span></span><br><span class="line"><span class="addition">+    ~WorkerGroup() throw();</span></span><br></pre></td></tr></table></figure>
<p>显式指示不抛出异常即可。或者用 noexcept 也行。</p>
<h2 id="multiple-definition"><a href="#multiple-definition" class="headerlink" title="multiple definition"></a>multiple definition</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: encoder.o:/root/parsec-3.0/pkgs/kernels/dedup/obj/amd64-linux.gcc/encoder.c:65: multiple definition of `conf&#x27;; dedup.o:/root/parsec-3.0/pkgs/kernels/dedup/obj/amd64-linux.gcc/dedup.c:25: first defined here</span><br><span class="line">/usr/bin/ld: decoder.o:/root/parsec-3.0/pkgs/kernels/dedup/obj/amd64-linux.gcc/decoder.c:39: multiple definition of `conf&#x27;; dedup.o:/root/parsec-3.0/pkgs/kernels/dedup/obj/amd64-linux.gcc/dedup.c:25: first defined here</span><br><span class="line">/usr/bin/ld: decoder.o:/root/parsec-3.0/pkgs/kernels/dedup/obj/amd64-linux.gcc/decoder.c:42: multiple definition of `cache&#x27;; encoder.o:/root/parsec-3.0/pkgs/kernels/dedup/obj/amd64-linux.gcc/encoder.c:68: first defined here</span><br></pre></td></tr></table></figure>
<p>gcc 10 后，默认使能了  -fno-common  选项，编译器检查更加严格了 <a class="link"   href="https://gcc.gnu.org/gcc-10/porting_to.html" >https://gcc.gnu.org/gcc-10/porting_to.html<i class="fas fa-external-link-alt"></i></a>。最简单的办法是，rollback(指定使用 -fcommon 编译代码即可)</p>
<h2 id="mismatched-comparison-between-std-ifstream-and-int"><a href="#mismatched-comparison-between-std-ifstream-and-int" class="headerlink" title="mismatched comparison between std::ifstream and int"></a>mismatched comparison between std::ifstream and int</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE_UTILITIES.h:83:49: error: no match for ‘operator!=’ (operand types are ‘std::ofstream’ &#123;aka ‘std::basic_ofstream&lt;char&gt;’&#125; and ‘int’)</span><br><span class="line">   83 |         return std::ofstream (filename.c_str()) != 0;</span><br><span class="line">      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~</span><br><span class="line">      |                     |                              |</span><br><span class="line">      |                     |                              int</span><br><span class="line">      |                     std::ofstream &#123;aka std::basic_ofstream&lt;char&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>std::ofstream 和 int 之间无法直接比较，需要强转，举个栗子，</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// FILE_UTILITIES.h</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	return std::ifstream (filename.c_str()) != 0;</span></span><br><span class="line"><span class="addition">+	return (bool)std::ifstream (filename.c_str()) != 0;</span></span><br></pre></td></tr></table></figure>


<h2 id="error-‘HUGE’-undeclared"><a href="#error-‘HUGE’-undeclared" class="headerlink" title="error: ‘HUGE’ undeclared"></a>error: ‘HUGE’ undeclared</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">LSH_query.c:361:34: error: ‘HUGE’ undeclared (first use in this function)</span><br><span class="line">  361 |         TOPK_INIT(topk, dist, K, HUGE);</span><br></pre></td></tr></table></figure>
<p>没有定义 <code>HUGE</code> 宏。我们将 C 数学库里的 HUGE_VAL 定义为 HUGE即可，<code>#define HUGE HUGE_VAL</code></p>
<h2 id="conflicting-type-mbstate-t-both-provided-by-glibc-and-parsec-lib"><a href="#conflicting-type-mbstate-t-both-provided-by-glibc-and-parsec-lib" class="headerlink" title="conflicting type __mbstate_t, both provided by glibc and parsec lib"></a>conflicting type __mbstate_t, both provided by glibc and parsec lib</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/usr/include/bits/types/__mbstate_t.h:21:3: error: conflicting types for ‘__mbstate_t’; have ‘struct &lt;anonymous&gt;’</span><br><span class="line">   21 | &#125; __mbstate_t;</span><br></pre></td></tr></table></figure>
<p>C 库和 parsec 库同时提供了 __mbstate_t 的定义，二者冲突了，将 parsec 库提供的定义重命名。</p>
<h2 id="POD-document-had-syntax-errors"><a href="#POD-document-had-syntax-errors" class="headerlink" title="POD document had syntax errors"></a>POD document had syntax errors</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smime.pod around line 272: Expected text after =item, not a number</span><br><span class="line">smime.pod around line 276: Expected text after =item, not a number</span><br><span class="line">smime.pod around line 280: Expected text after =item, not a number</span><br><span class="line">smime.pod around line 285: Expected text after =item, not a number</span><br><span class="line">smime.pod around line 289: Expected text after =item, not a number</span><br><span class="line">POD document had syntax errors at /usr/bin/pod2man line 69.</span><br><span class="line">make: *** [Makefile:681: install_docs] Error 255</span><br></pre></td></tr></table></figure>
<p>提示POD doc 有语法错误，应该是软件升级，语法变了导致的。使用下面的脚本一键修正过来就好了，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 0 1 2 3 4 5 6 7 8 9</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Replacing &#x27;=item <span class="variable">$i</span>&#x27; to &#x27;=item C&lt;<span class="variable">$i</span>&gt;&#x27;&quot;</span></span><br><span class="line">	grep -rl <span class="string">&quot;=item <span class="variable">$i</span>&quot;</span> * | xargs sed -i <span class="string">&quot;s/=item <span class="variable">$i</span>/=item C&lt;<span class="variable">$i</span>&gt;/g&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>


<h1 id="PATCHES"><a href="#PATCHES" class="headerlink" title="PATCHES"></a>PATCHES</h1><p>1、<a class="link"   href="https://github.com/markyangcc/parsec3-patch/blob/main/0002-fix-error-looser-exception-specification-on-overridi.patch" >fix-error-looser-exception-specification-on-overridi.patch<i class="fas fa-external-link-alt"></i></a><br>2、<a class="link"   href="https://github.com/markyangcc/parsec3-patch/blob/main/0001-use-gnu11-gnu-11-std-to-build-parsec.patch" >use-gnu11-gnu-11-std-to-build-parsec.patch<i class="fas fa-external-link-alt"></i></a><br>3、<a class="link"   href="https://github.com/markyangcc/parsec3-patch/blob/main/0007-fix-multiple-definition-when-build-with-gcc-10-or-ab.patch" >fix-multiple-definition-when-build-with-gcc-10-or-ab.patch<i class="fas fa-external-link-alt"></i></a><br>4、<a class="link"   href="https://github.com/markyangcc/parsec3-patch/blob/main/0004-fix-A-mismatched-comparison-between-std-ifstream-and.patch" >fix-A-mismatched-comparison-between-std-ifstream-and.patch<i class="fas fa-external-link-alt"></i></a><br>5、<a class="link"   href="https://github.com/markyangcc/parsec3-patch/blob/main/0005-fix-HUGE-macro-undeclared-error.patch" >fix-HUGE-macro-undeclared-error.patch<i class="fas fa-external-link-alt"></i></a><br>6、<a class="link"   href="https://github.com/markyangcc/parsec3-patch/blob/main/0006-fix-conflicting-type-__mbstate_t-both-provided-by-gl.patch" >fix-conflicting-type-__mbstate_t-both-provided-by-gl.patch<i class="fas fa-external-link-alt"></i></a><br>7、<a class="link"   href="https://github.com/markyangcc/parsec3-patch/blob/main/0003-fix-POD-document-had-syntax-errors.patch" >fix-POD-document-had-syntax-errors.patch<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>parsec</tag>
        <tag>RHEL 9</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>Run Your Own OBS 编译系统</title>
    <url>/run-your-own-obs-open-build-service.html</url>
    <content><![CDATA[<p>OBS（Open Build Service）是一个由 SUSE 开源的操作系统发行版的构建系统，可以用来创建和分发软件包。OBS支持几乎所有的主流发行版的包，比如说 SUSE系，RedHat系，Debian系，Arch系等等。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>安装 OBS 最简单的方式就是使用 <a class="link"   href="https://openbuildservice.org/download/" >openbuildservice<i class="fas fa-external-link-alt"></i></a> 网站提供的镜像（iso&#x2F;qcow2&#x2F;vmdk&#x2F;vdi），将镜像部署机器上就获得一个 OBS 实例。</p>
<p>通常情况下，使用 SUSE 制作好的虚拟机镜像是最省时间的，比如,</p>
<ul>
<li>使用 qemu-kvm, 下载 qcow2 镜像</li>
<li>使用 VMware, 下载 vmdk 镜像</li>
<li>使用 virtualbox, 下载 vdi 镜像</li>
</ul>
<p>也可以使用 SUSE 提供的 ISO 镜像重新安装一台 OBS 实例，缺点是需要等待 ISO 安装完成才能得到一台 OBS 实例，使用虚拟机镜像，启动后就可以获得 OBS 实例，节省了 ISO 的安装时间。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在 Linux 平台部署 OBS 应该是大多数人的需求。当然也很简单，Linux 平台下大家经常使用 libvirt&#x2F;qemu 组合创建虚拟机，使用 <code>virt-install</code> 会比写 libvirt xml 或写 qemu 命令行简单一些</p>
<p>可以使用 virt-install 命令行快速创建一个 OBS 实例,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">VM_NAME=&quot;OBS&quot;</span><br><span class="line">DISK=&quot;obs-server.x86_64-qcow2.qcow2&quot;</span><br><span class="line"></span><br><span class="line">virt-install \</span><br><span class="line">--name &quot;$&#123;VM_NAME&#125;&quot; \</span><br><span class="line">--memory 32768 \</span><br><span class="line">--vcpus 16 \</span><br><span class="line">--import \</span><br><span class="line">--os-variant opensuse15.3 \</span><br><span class="line">--disk &quot;$&#123;DISK&#125;&quot; \</span><br><span class="line">--network network=default,model=virtio \</span><br><span class="line">--graphics none \</span><br><span class="line">--virt-type kvm</span><br></pre></td></tr></table></figure>
<p>注：cpu 和 内存可以根据 host 机器的实际 cpu 和内存进行调整，示例是 16 核 32g 的配置，网络是 libvirt 创建的默认网络 <code>default</code>。</p>
<p>默认的登录名和密码分别是 <code>root</code> &#x2F; <code>opensuse</code> 。登录方式为, <code>virsh console &lt;VM_NAME&gt;</code>.</p>
<h3 id="Host-配置端口转发"><a href="#Host-配置端口转发" class="headerlink" title="Host 配置端口转发"></a>Host 配置端口转发</h3><blockquote>
<p>注：如果你是使用笔记本等拥有显示器的 host 机器，忽略本步骤。</p>
<p>注：如果你能为这台 OBS 实例分配单独的 IP，忽略本步骤。</p>
</blockquote>
<p>OBS 实例安装完成，为了能够在浏览器上访问这台 IP 为 <code>192.168.x.x</code> 的实例页面。我们需要在 Host 上配置端口转发，将 OBS 实例的流量转发到 host 机器上对应端口。</p>
<p>使用 nginx 实现端口转发，</p>
<p>修改 <code>/etc/nginx/nginx.conf</code>， 添加 server 转发规则，</p>
<p>配置 443 端口转发,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name _;  # 不需要填，使用 _ 代替即可</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/nginx/ssl/nginx.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/nginx.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">            proxy_pass https://192.168.122.100:443;          # 转发目标地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>443 转发需要配置证书的，本地使用 openssl 自签一个，一直回车即可，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/nginx/ssl</span><br><span class="line">openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt</span><br></pre></td></tr></table></figure>

<p>解释：转发配置的是将 host 443 端口的 http 流量全部转发到 <code>http://192.168.122.100:443</code>。</p>
<p>为了简单，我这里选择的是同端口映射，也就是 443 映射 443，也可以把 <code>listen 443;</code> 换成 <code>listen 4433;</code> 等其他端口。那么访问时候，带上端口号即可。</p>
<p>配置 80 端口转发(可以不配置，OBS 不需要这个端口),</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen 80;</span><br><span class="line">    server_name _;</span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://192.168.122.100:80;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后， 执行 <code>systemctl reload nginx</code> reload NGINX</p>
<p>现在打开浏览器，可以看到 OBS 的页面了。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>OBS 镜像首次启动至少需要 10 分钟，使用 vnc 连接服务器就可以看到 OBS 实例的启动卡在这个地方，待会会介绍这里进行的实际是 OBS 读取 fqdn，默认超时时间是 10 mins (shit code…)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A start job is running for OBS API Setup (8min 34s / no limit )</span><br></pre></td></tr></table></figure>

<p>journal 看日志可以看到，setup-appliance.sh 脚本在持续等待 fqdn，而且超时时间设置为 600 秒，也就是 10mins，感觉时间设置的过长了，如果本地网络比较好的话，改下脚本将超时时间设置为 十几秒就够了<br><img   src="/../img/obs-set-fqdn-journal-log.png"  alt="image.png"></p>
<p>&#x2F;usr&#x2F;lib&#x2F;obs&#x2F;server&#x2F;setup-appliance.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function get_hostname &#123;</span><br><span class="line"></span><br><span class="line">  if [[ $1 &amp;&amp; $BOOTSTRAP_TEST_MODE == 1 ]];then</span><br><span class="line">    FQHOSTNAME=$1</span><br><span class="line">  else</span><br><span class="line">    TIMEOUT=600</span><br><span class="line">    while [ -z &quot;$FQHOSTNAME&quot; -o &quot;$FQHOSTNAME&quot; = &quot;localhost&quot; ];do</span><br><span class="line">      FQHOSTNAME=`hostname -f 2&gt;/dev/null`</span><br><span class="line">      TIMEOUT=$(($TIMEOUT-1))</span><br><span class="line">      [ &quot;$TIMEOUT&quot; -le 0 ] &amp;&amp; break</span><br><span class="line">      echo &quot;Waiting for FQHOSTNAME ($TIMEOUT)&quot;</span><br><span class="line">      sleep 1</span><br><span class="line">    done</span><br><span class="line">  fi</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超时时间设置为 600 s ，在目前的网络条件下可能是没有必要的，改为十几秒足够了<br>注：在目前版本的 OBS  Git 仓库上，超时时间已经被调整为 30 s 了（<a class="link"   href="https://github.com/openSUSE/open-build-service/blob/c5ad76b359fd8b2ad77a597fa7cd65ed47b93d76/dist/functions.setup-appliance.sh#L144" >functions.setup-appliance.sh<i class="fas fa-external-link-alt"></i></a>），感觉这才是比较合理的值</p>
<h3 id="设置-ssh-服务开机自启"><a href="#设置-ssh-服务开机自启" class="headerlink" title="设置 ssh 服务开机自启"></a>设置 ssh 服务开机自启</h3><p>默认 OBS 2.10 镜像是没有开启 ssh 远程连接的，推荐开启，方便远程登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable --now sshd</span><br></pre></td></tr></table></figure>
<p>云厂商虚拟机可以先通过控制台的 vnc 连接到服务器，执行以上命令。之后可以通过 ssh 连接 OBS 实例了，OBS 镜像默认的登录用户名和密码是 root&#x2F;opensuse 。</p>
<p>现在针对各个云服务器的攻击非常多，保持默认密码很容易被攻击者入侵服务器，导致服务器成为肉鸡。。<br>为了安全起见，在以下几种方案里选择一个方式保护自己的云服务器<br>1、禁用密码登录、采用公钥登录，目前最安全的方案<br>2、禁用 root 远程登录，新增一个用户用于远程登录，修改默认 ssh 端口号，安全性适中<br>3、不禁用 root 远程登录，但是修改一个复杂一点的密码，修改默认 ssh 端口号，安全性弱</p>
<h3 id="更换国内镜像源"><a href="#更换国内镜像源" class="headerlink" title="更换国内镜像源"></a>更换国内镜像源</h3><p>OBS 默认的镜像源速度不是很理想，换成国内源加快安装软件包的速度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用已有所有镜像源</span></span><br><span class="line">zypper mr -da</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 USTC 的软件源</span></span><br><span class="line">zypper ar -fcg https://mirrors.ustc.edu.cn/opensuse/distribution/leap/\$releasever/repo/oss USTC:OSS</span><br><span class="line">zypper ar -fcg https://mirrors.ustc.edu.cn/opensuse/distribution/leap/\$releasever/repo/non-oss USTC:NON-OSS</span><br><span class="line">zypper ar -fcg https://mirrors.ustc.edu.cn/opensuse/update/leap/\$releasever/oss USTC:UPDATE-OSS</span><br><span class="line">zypper ar -fcg https://mirrors.ustc.edu.cn/opensuse/update/leap/\$releasever/non-oss USTC:UPDATE-NON-OSS</span><br><span class="line">zypper ar -fcg https://mirrors.ustc.edu.cn/opensuse/update/leap/\$releasever/sle USTC:UPDATE-SLE</span><br></pre></td></tr></table></figure>
<p>注：SUSE 系列 OS 存放 repo 文件的目录是<code>/etc/zypp/repos.d</code></p>
<h2 id="数据分盘（强烈推荐）"><a href="#数据分盘（强烈推荐）" class="headerlink" title="数据分盘（强烈推荐）"></a>数据分盘（强烈推荐）</h2><p><strong>如果你是想搭建一个试一下或者自己使用，并不是用于企业的生产环境，可以跳过这一步。</strong><br>OBS 作为一个打包系统，数据虽然不是特别的重要，但是还是建议将 OBS 的数据分盘存储。<br>在介绍数据分盘的逻辑前，先介绍一下 OBS 镜像本身，下载下来的 OBS 镜像安装好后是一个 openSUSE leap 15.3 系统，我们的 OBS 服务安装在 openSUSE 操作系统上的，更具体来说，是安装在<code>/srv</code> 目录下，所以数据分盘的逻辑就很显而易见了。将 OBS <code>/srv </code>目录单独放到一个数据盘上，剩下的作为系统盘。</p>
<h3 id="分盘操作原理"><a href="#分盘操作原理" class="headerlink" title="分盘操作原理"></a>分盘操作原理</h3><p>我们可以很轻松的联想到，单独给我们 OBS 虚拟机通一块数据盘，将数据盘挂在到 &#x2F;srv 分区，将原有的数据拷贝到数据盘上就可以实现 OBS 服务与系统盘脱钩。</p>
<h3 id="查看磁盘的情况"><a href="#查看磁盘的情况" class="headerlink" title="查看磁盘的情况"></a>查看磁盘的情况</h3><p>查看系统的磁盘情况，此处挂了一块 100G 的磁盘，被 Linux 系统标识为 &#x2F;dev&#x2F;vdb</p>
<blockquote>
<p>注：这里的 vda 是 &#x2F;dev&#x2F;vda，是系统盘，vda1 是在系统盘上分区，这里分区设置是将整个磁盘的空间全部分给 vda1，这里没必要讲磁盘分区。官方提供的 OBS 镜像里做了分区，那就保持这样就好了，系统盘和我们的数据分盘操作关系不大。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  368K  0 rom</span><br><span class="line">vda    253:0    0  100G  0 disk</span><br><span class="line">`-vda1 253:1    0  100G  0 part /</span><br><span class="line">vdb    253:16   0  100G  0 disk</span><br></pre></td></tr></table></figure>
<h3 id="磁盘需要格式化为文件系统"><a href="#磁盘需要格式化为文件系统" class="headerlink" title="磁盘需要格式化为文件系统"></a>磁盘需要格式化为文件系统</h3><p>将单独的数据盘 vdb 全盘格式化为 ext4 文件系统，此处不需要将磁盘分区为 1,2,3。（可以，但没必要）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs -t ext4 /dev/vdb</span><br></pre></td></tr></table></figure>

<p>将格式化好的磁盘挂在到 &#x2F;mnt 目录，（挂载到 &#x2F;mnt 目录下是为了拷贝数据用的，算是个临时目录 ）接着将 &#x2F;srv 目录下的所有文件同步到 &#x2F;mnt 目录，也就是同步到单独的数据盘上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/vdb /mnt</span><br><span class="line">rsync -av --progress /srv/ /mnt</span><br></pre></td></tr></table></figure>

<h3 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h3><p>在 systemd 启动 OBS 服务之前，我们需要将我们的数据盘 mount 到 &#x2F;sev 目录下，隐藏原有的文件。这样当 systemd 拉起 OBS 服务是时候，读取的数据就是从<br>通过 <code>lsblk -f</code> 命令查询 &#x2F;dev&#x2F;vdb 磁盘的 uuid 号，将数据盘开机挂载到 &#x2F;srv 目录， Linux mount 会隐藏原有目录的内容，不用担心 &#x2F;srv 目录非空，OBS 运行过程中对 &#x2F;srv 目录下的文件读写会写到系统盘上的位置，这种情况是不会发生的，这个是文件系统的实现，mount 过后，对 &#x2F;srv 路径下所有文件读写都会被文件系统重定向到 mount 的数据盘上。<br>mount 之后，这样每次 OBS 服务启动时读取的数据都是从单独的数据盘上读的，这样实现数据分离。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/fatab</span></span><br><span class="line">UUID=bedc29dd-b6c7-408d-917e-05d13111e056 /     ext4 defaults 1 1</span><br><span class="line">UUID=ba63af21-95d4-4fcc-b77e-a4e8de89280c /srv  ext4 defaults 1 1</span><br></pre></td></tr></table></figure>
<p>这里有一个问题，要不要在上一步的 rsync 过后，将原有的 &#x2F;srv 目录清空，其实是可以的，但是没有必要。</p>
<p>此时我们已经完成了 OBS 的数据分盘。</p>
<h2 id="为-OBS-添加-build-target"><a href="#为-OBS-添加-build-target" class="headerlink" title="为 OBS 添加 build target"></a>为 OBS 添加 build target</h2><p>默认情况下，新创建的 OBS 是没有 build target。添加了对应发行版的 build target 后，就可以为对应的发行版编译软件包了。<br>我们查看 <a class="link"   href="https://build.opensuse.org/project" >https://build.opensuse.org<i class="fas fa-external-link-alt"></i></a> 网站上，发现拥有许多 build target，比如说 CentOS 7, CentOS 8，CentOS Stream，SUSE SLE，openSUSE，AlmaLinux，RockyLinux，Debian 等等。</p>
<p>推荐先创建一个 Meta 项目，在以这个 Meta 项目作为基石，创建 AlmaLinux:9 的编译环境。</p>
<h3 id="1-为发行版编译项目创建一个-meta-项目"><a href="#1-为发行版编译项目创建一个-meta-项目" class="headerlink" title="1) 为发行版编译项目创建一个 meta 项目"></a>1) 为发行版编译项目创建一个 meta 项目</h3><p>创建 meta 项目是必要的，后面会介绍。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">osc meta -e prj Meta:AlmaLinux:9</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;project name=&quot;Meta:AlmaLinux:9&quot;&gt;</span><br><span class="line">  &lt;title&gt;Meta AlmaLinux 9&lt;/title&gt;</span><br><span class="line">  &lt;description/&gt;</span><br><span class="line">  &lt;person userid=&quot;Admin&quot; role=&quot;maintainer&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;repository name=&quot;standard&quot;&gt;</span><br><span class="line">    &lt;arch&gt;x86_64&lt;/arch&gt;</span><br><span class="line">  &lt;/repository&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写好项目的 build target 之后，会自动创建如下目录<br><code>/srv/obs/build/AlmaLinux:9/standard/x86_64</code></p>
<h3 id="2-添加编译依赖-rpm-包（BuildRequire-）"><a href="#2-添加编译依赖-rpm-包（BuildRequire-）" class="headerlink" title="2) 添加编译依赖 rpm 包（BuildRequire ）"></a>2) 添加编译依赖 rpm 包（BuildRequire ）</h3><p>对于 AlmaLinux 来说，以 repo粒度来说最小化的依赖包是 baseos 和 appstream 里面的包。但是通常情况下，这些包是不够用的，比如说编译 kernel, 还需要 crb 和 epel 里的包。<br>这里推荐将发行版的，baseos, appstream, crb, epel 仓库的对应 arch 的包都下载到 :full 路径下作为依赖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /srv/obs/build/Meta:AlmaLinux:9/standard/x86_64/:full</span><br><span class="line"></span><br><span class="line">cp &lt;needed-packages-to-build-packages&gt;/*.rpm /srv/obs/build/Meta:AlmaLinux:9/standard/x86_64/:full/</span><br><span class="line">chown -R obsrun.obsrun /srv/obs/build/Meta:AlmaLinux:9</span><br></pre></td></tr></table></figure>
<h3 id="3-添加项目的配置文件"><a href="#3-添加项目的配置文件" class="headerlink" title="3) 添加项目的配置文件"></a>3) 添加项目的配置文件</h3><p>没添加 project config 之前，项目是处于 broken 状态的<br><img   src="/../img/obs-broken-status.png"  alt="obs-broken-status"></p>
<p>添加也很简单，将 openSUSE  网站的 project conf 复制过来即可<br><a class="link"   href="https://build.opensuse.org/projects/AlmaLinux:9/prjconf" >https://build.opensuse.org/projects/AlmaLinux:9/prjconf<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="4-扫描项目解决依赖"><a href="#4-扫描项目解决依赖" class="headerlink" title="4) 扫描项目解决依赖"></a>4) 扫描项目解决依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">obs_admin --rescan-repository Meta:AlmaLinux:9 standard x86_64</span><br></pre></td></tr></table></figure>

<p>执行完 rescan-repository 命令后，如果出现 :repodone 文件代表文件扫描完毕<br>如果配置不完整，查下目录下的文件里面的内容，可以看出报错出在哪里</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /srv/obs/build/AlmaLinux:9/standard/x86_64</span></span><br><span class="line">:bininfo  :depends  :full  :full.solv  :packstatus  :repodone  :repoinfo  :schedulerstate</span><br></pre></td></tr></table></figure>
<p>5）以 meta 项目为基础创建发行版编译项目<br>添加完 build target 之后，就可以为这个发行版构建软件包了<br><img   src="/../img/obs-public-status.png"  alt="obs-public-status"></p>
<h3 id="5）如法炮制，创建一个用于发行版编译的项目"><a href="#5）如法炮制，创建一个用于发行版编译的项目" class="headerlink" title="5）如法炮制，创建一个用于发行版编译的项目"></a>5）如法炮制，创建一个用于发行版编译的项目</h3><p>前面 4 个步骤中，我们已经创建了 一个 Meta 项目，但是这个项目并不能作为发行版编译的项目，需要以 meta 项目为模板创建用于发行版编译的项目<br>因为在 OBS 里所有的项目都是一样的，这里和创建 meta 项目一样创建一个用于发行版编译的项目。<br>这里的区别是，repository 标签的写法，我们复用了之前创建的 meta 项目。创建完成，扫描仓库解决依赖后就可以正式用作编译的仓库了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">osc meta -e prj AlmaLinux:9</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;project name=&quot;AlmaLinux:9&quot;&gt;</span><br><span class="line">  &lt;title&gt;AlmaLinux 9&lt;/title&gt;</span><br><span class="line">  &lt;description&gt;AlmaLinux 9 distribution project.</span><br><span class="line"></span><br><span class="line">  &lt;/description&gt;</span><br><span class="line">  &lt;person userid=&quot;Admin&quot; role=&quot;maintainer&quot;/&gt;</span><br><span class="line">  &lt;repository name=&quot;standard&quot;&gt;</span><br><span class="line">    &lt;path project=&quot;Meta:AlmaLinux:9&quot; repository=&quot;standard&quot;/&gt;</span><br><span class="line">    &lt;arch&gt;x86_64&lt;/arch&gt;</span><br><span class="line">  &lt;/repository&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">obs_admin --rescan-repository AlmaLinux:9 standard x86_64</span><br></pre></td></tr></table></figure>

<p>现在可以为 AlmaLinux 编译软件包了，如下图<br><img   src="/img/obs-build-success-status.png"  alt="obs-build-success-status"></p>
<h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><h3 id="OBS-使用-qemu-kvm-作为构建环境会构建失败"><a href="#OBS-使用-qemu-kvm-作为构建环境会构建失败" class="headerlink" title="OBS 使用 qemu-kvm 作为构建环境会构建失败"></a>OBS 使用 qemu-kvm 作为构建环境会构建失败</h3><p>OBS 默认采用 qemu-kvm 创建的虚拟机作为编译环境，采用 qemu-kvm 作为构建方式很多情况下会报错，导致构建失败。这个问题没有仔细研究过，有一个 workaround 可以比较简单的解决这个问题，那就是将 qemu-kvm 命令重命名，然后重启 obsworker.service 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /usr/bin/qemu-kvm /usr/bin/qemu-kvm.bak</span><br><span class="line">systemctl restart obsworker.service</span><br></pre></td></tr></table></figure>

<h3 id="waiting-for-8-compliant-workers-8-of-them-bad"><a href="#waiting-for-8-compliant-workers-8-of-them-bad" class="headerlink" title="waiting for 8 compliant workers (8 of them bad)"></a>waiting for 8 compliant workers (8 of them bad)</h3><p>执行以下命令可以解决这个问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">obs_admin --drop-badhosts</span><br></pre></td></tr></table></figure>

<h3 id="warning-Signature-not-supported-Hash-algorithm-SHA1-not-available"><a href="#warning-Signature-not-supported-Hash-algorithm-SHA1-not-available" class="headerlink" title="warning: Signature not supported. Hash algorithm SHA1 not available"></a>warning: Signature not supported. Hash algorithm SHA1 not available</h3><p>因为 OBS 默认采用 SHA1 算法为 RPM 包签名，在一些系统上比如 RHEL 9 上 sha1 算法被弃用。因为 OBS 为了保证兼容性，默认的签名算法依然是 sha1。<br>通过编辑 sign.conf 文件可以将签名算法改为 sha256。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/sign.conf</span></span><br><span class="line">user: obsrun@localhost</span><br><span class="line">server: 127.0.0.1</span><br><span class="line">allowuser: obsrun</span><br><span class="line">allow: 127.0.0.1</span><br><span class="line">hash: sha256</span><br><span class="line">phrases: /srv/obs/gnupg/phrases</span><br></pre></td></tr></table></figure>

<h3 id="obs-页面点击下载会被重定向回首页"><a href="#obs-页面点击下载会被重定向回首页" class="headerlink" title="obs 页面点击下载会被重定向回首页"></a>obs 页面点击下载会被重定向回首页</h3><p>修改 external_frontend 可以解决这个问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /srv/www/obs/api/config/options.yml</span></span><br><span class="line"></span><br><span class="line">external_frontend_host: &lt;ip or hostname&gt;</span><br><span class="line">external_frontend_port: 443</span><br><span class="line">external_frontend_protocol: https</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、Archive:Build Service adding build targets<br><a class="link"   href="https://en.opensuse.org/Archive:Build_Service_adding_build_targets" >https://en.opensuse.org/Archive:Build_Service_adding_build_targets<i class="fas fa-external-link-alt"></i></a><br>2、Local OBS doesn’t build anymore (waiting for 4 compliant workers (4 of them bad))<br><a class="link"   href="https://lists.opensuse.org/archives/list/buildservice@lists.opensuse.org/thread/EGWPVEZXSBAB3TTFKPERUNBU5SWECYNB/" >https://lists.opensuse.org/archives/list/buildservice@lists.opensuse.org/thread/EGWPVEZXSBAB3TTFKPERUNBU5SWECYNB/<i class="fas fa-external-link-alt"></i></a><br>3、Enhancing RHEL Security: Understanding SHA-1 deprecation on RHEL 9<br><a class="link"   href="https://www.redhat.com/en/blog/rhel-security-sha-1-package-signatures-distrusted-rhel-9" >https://www.redhat.com/en/blog/rhel-security-sha-1-package-signatures-distrusted-rhel-9<i class="fas fa-external-link-alt"></i></a><br>4、man sign.conf<br>5、初始化Linux数据盘<br> <a class="link"   href="https://support.huaweicloud.com/qs-ecs/zh-cn_topic_0085634797.html" >https://support.huaweicloud.com/qs-ecs/zh-cn_topic_0085634797.html<i class="fas fa-external-link-alt"></i></a><br>6、openSUSE 源使用帮助<br><a class="link"   href="https://mirrors.ustc.edu.cn/help/opensuse.html" >https://mirrors.ustc.edu.cn/help/opensuse.html<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>OBS</tag>
        <tag>build system</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 ebpf USDT 追踪用户态程序</title>
    <url>/tracing-userspace-process-ebpf-usdt.html</url>
    <content><![CDATA[<p>USDT 是一种探针技术，让用户态程序也支持使用 perf&#x2F;ebpf 性能分析工具进行 tracing&#x2F;profiling。做性能分析通常听过 perf&#x2F;ebpf 这些工具，这些工具通常用在内核上，用于分析内核的一些性能问题，如果是用户态程序也遇到性能问题了，我们希望用户态程序也能使用 perf&#x2F;ebpf 工具进行 tracing&#x2F;profiling。那么就需要 USDT 技术了。</p>
<p>简单来说，USDT 就是探针技术，我们在源码里插入一个固定的探针。当我们 tracing 这个探针的时候，就获取我们埋点的数据了。</p>
<h2 id="USDT-如何插入探针？"><a href="#USDT-如何插入探针？" class="headerlink" title="USDT  如何插入探针？"></a>USDT  如何插入探针？</h2><p>插入探针，有时候也叫做埋点。只需要包含 &lt;sys&#x2F;sdt.h&gt; 头文件，然后利用 DTRACE_PROBE 系列函数埋点即可。</p>
<p>DTRACE_PROBE 系列函数定义在  <code>/usr/include/sys/sdt.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DTrace compatible macro names.  */</span></span><br><span class="line">DTRACE_PROBE(provider,probe)</span><br><span class="line">DTRACE_PROBE1(provider,probe,parm1)</span><br><span class="line">DTRACE_PROBE2(provider,probe,parm1,parm2)</span><br><span class="line">DTRACE_PROBE3(provider,probe,parm1,parm2,parm3)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>第一次看到DTRACE_PROBE1, 2, 3, 4 … 可能会有些懵，这都是啥呀？！</p>
<p>实际上很简单，而且用法也很简单，我用 DPDK l2fwd 举个例子，<br><a class="link"   href="https://git.dpdk.org/dpdk/tree/examples/l2fwd" >https://git.dpdk.org/dpdk/tree/examples/l2fwd<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">l2fwd_main_loop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; qconf-&gt;n_rx_port; i++) &#123;</span><br><span class="line">        </span><br><span class="line">		portid = qconf-&gt;rx_port_list[i];</span><br><span class="line">		nb_rx = rte_eth_rx_burst(portid, <span class="number">0</span>, pkts_burst, MAX_PKT_BURST);</span><br><span class="line">        </span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;portid: %d, queueid: %d, rcvd: %d\n&quot;</span>, portid, <span class="number">0</span>, nb_rx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码是一个利用 DPDK l2 fwd 里的示例代码， rte_eth_rx_burst 函数从网卡收包，我们想知道本次收包收了多少个，于是我们打了一条 log。</p>
<p>这样实现很不优雅，<strong>首先是在 datapath 打 log 是错误的决定</strong>。其次，我们只希望在 tracing 的时候打印结果，不 tracing 的时候不打印结果。使用 打 log 的方式是无法实现这种效果的，我们需要一个开关，能动态打开和关闭 tracing 的开关，当我们 attach 到这个探针时候，我们可以观测到数据，当我们 detach 的时候，就去掉这个探针，不增加额外的观测消耗。</p>
<p>USDT 可以实现动态开关的功能。我们只需要添加 &lt;sys&#x2F;sdt.h&gt; 头文件，将 log 语句替换为 DTRACE_PROBE3 语句即可。DTRACE_PROBE5 的数字 3 代表 3 个观测参数，前两个是标识参数，第一个通常用 appname 填充,第二个通常用函数名称填充。当我们使用 perf、ebpf 等观测工具时，通过这两个参数定位我们预先埋下的观测点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sdt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">l2fwd_main_loop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; qconf-&gt;n_rx_port; i++) &#123;</span><br><span class="line"></span><br><span class="line">		portid = qconf-&gt;rx_port_list[i];</span><br><span class="line">		nb_rx = rte_eth_rx_burst(portid, <span class="number">0</span>, pkts_burst, MAX_PKT_BURST);</span><br><span class="line"></span><br><span class="line">		DTRACE_PROBE3(l2fwd, l2fwd_main_loop, portid, <span class="number">0</span>, rcvd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="查看可用的探针"><a href="#查看可用的探针" class="headerlink" title="查看可用的探针"></a>查看可用的探针</h2><p>查看可用探针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -l <span class="string">&quot;usdt:/usr/bin/l2fwd:*&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看正在运行的进程的可用探针，会同时展示其链接的动态库的可用探针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -lp $(pidof l2fwd) <span class="string">&quot;usdt:*&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="USDT-使用"><a href="#USDT-使用" class="headerlink" title="USDT 使用"></a>USDT 使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bpftrace -e &#x27;usdt:/usr/bin/l2fwd:l2fwd_main_loop &#123; printf(&quot;%d,%d,%d\n&quot;,arg0,arg1,arg2); &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>bpftrace 内置许多参数，比如 comm, pid, cpu, elapsed，利用这些参数可以实现更高级的 tracing。<br>还可以通过 bcc&#x2F;libbpf 将一段时间的数据收集起来，进行统计，得出更宏观的指标，这样有一定的代码量。bpftrace 的优势就是一行，很简单。</p>
<h2 id="USDT-原理"><a href="#USDT-原理" class="headerlink" title="USDT 原理"></a>USDT 原理</h2><p>包含 USDT 的代码经过编译后生成的二进制文件将有一个名为 .stapsdt.base 的 ELF 段。这个 .stapsdt.base 有助于 tracing 工具在二进制文件加载到内存后计算探针的内存地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">readelf -S l2fwd | grep sdt</span></span><br><span class="line">  [17] .stapsdt.base     PROGBITS         00000000004053d0  000053d0</span><br><span class="line">  [28] .note.stapsdt     NOTE             0000000000000000  000061fc</span><br></pre></td></tr></table></figure>

<p>还有一个 ELF note，note 记录了探针的相关信息（名称、地址、信号量、参数）。用户态进程可以读取这个段获得探针的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Displaying notes found in: .note.stapsdt</span><br><span class="line">  Owner                Data size 	Description</span><br><span class="line">  stapsdt              0x00000042	NT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">    Provider: l2fwd</span><br><span class="line">    Name: l2fwd_main_loop</span><br><span class="line">    Location: 0x0000000000402596, Base: 0x00000000004053d0, Semaphore: 0x0000000000000000</span><br><span class="line">    Arguments: 4@%ebp -4@$0 4@%ecx</span><br></pre></td></tr></table></figure>
<h2 id="USDT-动态开关"><a href="#USDT-动态开关" class="headerlink" title="USDT 动态开关"></a>USDT 动态开关</h2><p>反汇编二进制，发现 DTRACE_PROBE 被编译为一条 nop 指令，当不进行 probe 时候，就是执行一条 nop 指令，当进行 probe 的时候替换为 int3 进行跳转到 hook 函数。<br><img   src="/../img/1706001641941-1e147d49-ec2e-4ecb-8cdc-6dbec57fbf17.png"  alt="image.png"></p>
]]></content>
      <tags>
        <tag>ebpf</tag>
        <tag>usdt</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6 Lab0: Prepare for the Lab</title>
    <url>/xv6-lab0-prepare-workspace.html</url>
    <content><![CDATA[<p>再开始 lab 之前，我们先进行环境配置。</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>看 xv6 网站上的教程，安装依赖软件包<br><a class="link"   href="https://pdos.csail.mit.edu/6.828/2023/tools.html" >https://pdos.csail.mit.edu/6.828/2023/tools.html<i class="fas fa-external-link-alt"></i></a></p>
<p>使用 Debina&#x2F;Ubuntu 系统, </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure>

<p>依赖安装完成后，编译运行 xv6，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://g.csail.mit.edu/xv6-labs-2023</span><br><span class="line">cd xv6-labs-2023</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>
<p><strong>特别备注： 执行 <code>make qemu</code>  会进入 xv6 系统里，想退出 qemu， 先按 ctrl + a, 紧接着按 x 即可退出 qemu。</strong></p>
<h3 id="配置-vscode-自动代码跳转"><a href="#配置-vscode-自动代码跳转" class="headerlink" title="配置 vscode 自动代码跳转"></a>配置 vscode 自动代码跳转</h3><p>当使用 vscode 编写 xv6 代码时候，即使安装 clangd，也是没有代码自动跳转的。因为 clangd 需要<br><code>compile_commands.json</code> 理解项目代码，才能实现正确的代码跳转。对于 xv6 项目，我们使用 bear 将整个项目完整编译一遍，bear 会为我们生成需要的 <code>compile_commands.json</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install bear</span><br><span class="line"></span><br><span class="line">cd xv6-labs-2023</span><br><span class="line">bear -- make</span><br></pre></td></tr></table></figure>

<p>More: <a class="link"   href="https://clangd.llvm.org/installation.html#compile_commandsjson" >https://clangd.llvm.org/installation.html#compile_commandsjson<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="禁用-vscode-clangd-插件自动插入头文件"><a href="#禁用-vscode-clangd-插件自动插入头文件" class="headerlink" title="禁用 vscode clangd 插件自动插入头文件"></a>禁用 vscode clangd 插件自动插入头文件</h3><p>有时候，vscode 的 clagnd 会自动为我们加入 glibc 的头文件，<br><strong>因为 xv6 不是 linux，也不使用 glibc，所以 clangd 自动加入的头文件也是错误的</strong>。 在 vscode 设置的 clangd 插件添加 <code>--header-insertion=never</code> 命令行选项，禁用自动插入头文件。重启 vscode 生效。<br>路径：<br><code>Settings -&gt; Extensions -&gt; clagnd -&gt; Clangd: Arguments -&gt; Add Item</code></p>
<h3 id="配置-clang-format-代码格式化"><a href="#配置-clang-format-代码格式化" class="headerlink" title="配置 clang-format 代码格式化"></a>配置 clang-format 代码格式化</h3><p>clang-format 可以用于自动格式化 C&#x2F;C++ 代码，为我们 xv6 写一个 .clang-format 文件后，使用 vscode 的快捷键可以自动格式化代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install clang-format</span><br></pre></td></tr></table></figure>

<p>使用如下配置，此配置的风格和 xv6 代码风格最为相似，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BasedOnStyle: LLVM</span><br><span class="line">SortIncludes: Never</span><br><span class="line"></span><br><span class="line">BreakBeforeBraces: Stroustrup</span><br><span class="line"></span><br><span class="line">SpaceBeforeParensOptions:</span><br><span class="line">  AfterControlStatements: true</span><br><span class="line">  AfterFunctionDefinitionName: true</span><br><span class="line"></span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: All</span><br></pre></td></tr></table></figure>

<p>clang-format 支持很多配置项，自定义一个自己的喜欢代码风格也不是一件难事。</p>
<p>More: <a class="link"   href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html" >https://clang.llvm.org/docs/ClangFormatStyleOptions.html<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
  </entry>
  <entry>
    <title>xv6 Lab1: Xv6 and Unix utilities</title>
    <url>/xv6-lab1-xv6-and-unix-utilities.html</url>
    <content><![CDATA[<p>Lab1 为 xv6 实现用户态程序。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>写第一个程序，主要的体会就是懵。不知道从哪下手，在看了内核态的对应实现，看了用户态 kill.c 的实现后，理清思路后，才发现 sleep 其实很简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ticks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep ticks...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ticks = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sleep(ticks);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>利用管道实现 pingpong，<code>fork() </code>的父子进程都拥有同样的 fd，父子进程可以通过向一端写，另一端阻塞读来实现 ping-pong, 管道的规范是 pipe 的 0 是读，1 是写，记住这个很好实现了。<br>另外，pingpong 只需要创建一个管道即可，无需为父子进程各自创建一条管道，然后 close 掉不用的通道。共用一条管道即可，这是因为 pingpong 程序不存在竞争的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> nr_read = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nr_write = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAX_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line"></span><br><span class="line">        nr_read = read(pipe_fds[<span class="number">0</span>], buf, MAX_BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (nr_read &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        nr_write = write(pipe_fds[<span class="number">1</span>], <span class="string">&quot;ping-pong&quot;</span>, MAX_BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (nr_write &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line"></span><br><span class="line">        nr_write = write(pipe_fds[<span class="number">1</span>], <span class="string">&quot;ping-pong&quot;</span>, MAX_BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (nr_write &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        nr_read = read(pipe_fds[<span class="number">0</span>], buf, MAX_BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (nr_read &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>利用 pipe + fork() 实现质数筛。核心思想如下图所示，首先一堆数 2-35，利用 2 将 2-35 树筛一遍，其中能被 2 整除的自然不是质数了，将不能被 2 整除的数保存下来，通过管道传递给子进程，子进程的得到的一系列数，利用第一个数 3 将不能被 3 整除的数保存下来，传递给子进程，接下来是 5,7 依次递归下去，每个进程打印出一个质数，最后结果就是所有质数。<br><img   src="/../img/1708324546344-eff1d2ab-81c4-4b74-b0d5-fd711f72b724.png"  alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUMBER 35</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">filter</span><span class="params">(<span class="type">int</span> pipe_read)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> primes[MAX_NUMBER];</span><br><span class="line">    <span class="type">int</span> nr_read;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nr_read = read(pipe_read, &amp; primes[cnt], <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (nr_read &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipe_read);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first = primes[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, first);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fds);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (primes[i] % first != <span class="number">0</span>) &#123;</span><br><span class="line">            write(pipe_fds[<span class="number">1</span>], &amp; primes[i], <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        filter(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAX_NUMBER; i++) &#123;</span><br><span class="line">        write(pipe_fds[<span class="number">1</span>], &amp; i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    filter(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>为 xv6 实现一个简单的 find。核心是理解如何遍历目录下的所有文件（看代码中的注释），代码可以直接参考 xv6 的 ls.c 修改得来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span> <span class="comment">//格式化名字，把名字变成前面没有左斜杠/，仅仅保存文件名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return blank-padded name.</span></span><br><span class="line">    memmove(buf, p, <span class="built_in">strlen</span>(p) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *dir, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(dir, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, dir);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, dir);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fmtname(dir), name) == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dir);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(dir) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> path) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">strcpy</span>(path, dir);</span><br><span class="line">            p = path + <span class="built_in">strlen</span>(path);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// path 追加 &#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hint: 目录也是一个 file，循环读取一个 struct dirent 大小，就可以遍历目录下所有文件</span></span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                memmove(p, de.name, DIRSIZ); <span class="comment">// memmove把 de.name 信息追加到 path</span></span><br><span class="line">                p[<span class="built_in">strlen</span>(de.name)] = <span class="number">0</span>;		 <span class="comment">// EOF</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// ignore &#x27;.&#x27; and &#x27;..&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                find(path, name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: find [path] [name]&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>为 xv6 实现一个 xargs。理解 xargs 的工作原理对于实现 xargs 是至关重要的。<br>示例，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo hello too | xargs echo bye</span><br><span class="line">bye hello too</span><br></pre></td></tr></table></figure>
<p>xargs 是从标准输入(stdin) 读取输入，并将输入作为自己的输入。所以上面的 echo 示例程序，首先 shell 执行 <code>echo hello too</code> 产生的 stdout  通过管道作为 xargs 的 stdin。然后 <code>hello too</code> 会被追加到 <code>bye</code> 后面，所以最终命令的结果是 <code>bye hello too</code>。<br>另外，xargs 遇到换行符 (‘\n’) 会结束本次处理，每一行 xargs 都会 fork + exec 产生一个新的进程进行处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *args[MAXARG];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; MAXARG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;xargs: too many args\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy xargs&#x27;s args</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        args[index] = argv[i];</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">char</span> *p = buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read each byte into buf, from stdin</span></span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, p, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            *p = <span class="number">0</span>; <span class="comment">// set &#x27;\n&#x27; to 0</span></span><br><span class="line">            <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                args[index] = buf; <span class="comment">// append args read from stdin into args[]</span></span><br><span class="line">                exec(argv[<span class="number">1</span>], args);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// parent</span></span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// Continue reading from stdin, resetting buf and reset the pointer</span></span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                p = buf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>最后 <code>make grade</code> 查看结果,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">== Test sleep, no arguments ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">sleep, no arguments: OK (3.5s)</span><br><span class="line">== Test sleep, returns ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">sleep, returns: OK (0.9s)</span><br><span class="line">== Test sleep, makes syscall ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">sleep, makes syscall: OK (1.1s)</span><br><span class="line">== Test pingpong ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">pingpong: OK (1.0s)</span><br><span class="line">== Test primes ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">primes: OK (1.0s)</span><br><span class="line">== Test find, in current directory ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">find, in current directory: OK (1.1s)</span><br><span class="line">== Test find, recursive ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">find, recursive: OK (1.3s)</span><br><span class="line">== Test xargs ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">xargs: OK (1.5s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure>

<p>至此， lab 的所有程序都结束了。下面的部分对于我们舒服的写代码有很大帮助，介绍了如何为 vscode 配置 clangd + clang-format 提供 xv6 的代码自动跳转以及格式化。</p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
  </entry>
  <entry>
    <title>Reboot 命令实际是 systemctl？</title>
    <url>/reboot_is_link_to_systemctl.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在一次查问题的过程中，偶然发现 reboot 命令是<strong>直接链接</strong>到 systemctl 的（划重点：直接链接到），看下面的演示，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which reboot</span></span><br><span class="line">/sbin/reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># file /sbin/reboot</span></span><br><span class="line">/sbin/reboot: symbolic <span class="built_in">link</span> to ../bin/systemctl</span><br></pre></td></tr></table></figure>

<p>第一直觉就是这是不是不合理，直接把 reboot 软链到 systemctl ，不就相当于直接执行 systemctl 命令，这怎么会起到 reboot 的作用的呢？</p>
<p>继续看，</p>
<p>发现 <code>/sbin</code> 目录下很多命令都是直接软链到 <code>systemctl</code>，没有参数来区分，而且这些命令是 100% 工作的，当数量多起来的时候，事情逐渐合理起来了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file /sbin/* | grep symbolic | grep systemctl</span></span><br><span class="line">/sbin/halt:                  symbolic <span class="built_in">link</span> to ../bin/systemctl</span><br><span class="line">/sbin/poweroff:              symbolic <span class="built_in">link</span> to ../bin/systemctl</span><br><span class="line">/sbin/reboot:                symbolic <span class="built_in">link</span> to ../bin/systemctl</span><br><span class="line">/sbin/runlevel:              symbolic <span class="built_in">link</span> to ../bin/systemctl</span><br><span class="line">/sbin/shutdown:              symbolic <span class="built_in">link</span> to ../bin/systemctl</span><br><span class="line">/sbin/telinit:               symbolic <span class="built_in">link</span> to ../bin/systemctl</span><br></pre></td></tr></table></figure>

<p>那 systemctl 是如何区分出这些命令的？</p>
<p>熟悉 C 编程的同学大概率可以猜到了，systemctl 可能是通过进程名来区分的，也就是 <code>argv[0]</code> 这个参数，C 语言里 <code>argv[0]</code> 保存的是程序的名称（其他语言也有类似的参数）。</p>
<h2 id="那拿-systemctl-测试一下？"><a href="#那拿-systemctl-测试一下？" class="headerlink" title="那拿 systemctl 测试一下？"></a>那拿 systemctl 测试一下？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@cs8 ~]# <span class="built_in">ln</span> -sf /usr/bin/systemctl testcmd</span><br><span class="line">[root@cs8 ~]# ./testcmd</span><br><span class="line">UNIT                                                                                LOAD   ACTIVE SUB       DESCRIPTION</span><br><span class="line">proc-sys-fs-binfmt_misc.automount                                                   loaded active waiting   Arbitrary Executable File Formats File System Automount Point</span><br><span class="line">sys-devices-pci0000:00-0000:00:05.0-virtio0-net-eth0.device                         loaded active plugged   Virtio network device</span><br><span class="line">sys-devices-pci0000:00-0000:00:06.0-virtio1-block-vda-vda1.device                   loaded active plugged   /sys/devices/pci0000:00/0000:00:06.0/virtio1/block/vda/vda1</span><br><span class="line">sys-devices-pci0000:00-0000:00:06.0-virtio1-block-vda.device                        loaded active plugged   /sys/devices/pci0000:00/0000:00:06.0/virtio1/block/vda</span><br></pre></td></tr></table></figure>

<p>可以看到 systemctl 并不识别 testcmd 命令，而是打印了所有 uints，等价 <code>systemctl</code> 直接执行。</p>
<h2 id="看代码"><a href="#看代码" class="headerlink" title="看代码"></a>看代码</h2><p>和我们预想的一样，systemctl 内部通过 argv 来判断由谁调用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// systemd/src/systemctl/systemctl.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">systemctl_dispatch_parse_argv</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">        assert(argc &gt;= <span class="number">0</span>);</span><br><span class="line">        assert(argv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invoked_as(argv, <span class="string">&quot;halt&quot;</span>)) &#123;</span><br><span class="line">                arg_action = ACTION_HALT;</span><br><span class="line">                <span class="keyword">return</span> halt_parse_argv(argc, argv);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invoked_as(argv, <span class="string">&quot;poweroff&quot;</span>)) &#123;</span><br><span class="line">                arg_action = ACTION_POWEROFF;</span><br><span class="line">                <span class="keyword">return</span> halt_parse_argv(argc, argv);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invoked_as(argv, <span class="string">&quot;reboot&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (kexec_loaded())</span><br><span class="line">                        arg_action = ACTION_KEXEC;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        arg_action = ACTION_REBOOT;</span><br><span class="line">                <span class="keyword">return</span> halt_parse_argv(argc, argv);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invoked_as(argv, <span class="string">&quot;shutdown&quot;</span>)) &#123;</span><br><span class="line">                arg_action = ACTION_POWEROFF;</span><br><span class="line">                <span class="keyword">return</span> shutdown_parse_argv(argc, argv);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invoked_as(argv, <span class="string">&quot;init&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sd_booted() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        arg_action = _ACTION_INVALID;</span><br><span class="line">                        <span class="keyword">return</span> telinit_parse_argv(argc, argv);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        arg_action = ACTION_TELINIT;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (invoked_as(argv, <span class="string">&quot;runlevel&quot;</span>)) &#123;</span><br><span class="line">                arg_action = ACTION_RUNLEVEL;</span><br><span class="line">                <span class="keyword">return</span> runlevel_parse_argv(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arg_action = ACTION_SYSTEMCTL;</span><br><span class="line">        <span class="keyword">return</span> systemctl_parse_argv(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自己实现一个"><a href="#自己实现一个" class="headerlink" title="自己实现一个"></a>自己实现一个</h2><p>实现也很简单，几行代码就行。只需要实现通过 argv[0] 识别调用方是谁，然后根据不同的调用方执行不同的逻辑即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // 提取程序名（最后一个斜杠后的内容）</span><br><span class="line">    char *programName = strrchr(argv[0], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (programName != NULL) &#123;</span><br><span class="line">        programName++; // 移动到斜杠后的第一个字符</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        programName = argv[0]; // 如果没有斜杠，直接使用整个参数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据程序名执行不同的逻辑</span><br><span class="line">    <span class="keyword">if</span> (strcmp(programName, <span class="string">&quot;programA&quot;</span>) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;执行程序 A 的逻辑\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(programName, <span class="string">&quot;programB&quot;</span>) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;执行程序 B 的逻辑\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知程序，执行默认逻辑\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完结撒花</p>
]]></content>
      <tags>
        <tag>reboot</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6 Lab2: system calls</title>
    <url>/xv6-lab2-system-calls.html</url>
    <content><![CDATA[<p>Lab2 实现 2 个 syscall。</p>
<h2 id="Using-gdb"><a href="#Using-gdb" class="headerlink" title="Using gdb"></a>Using gdb</h2><p>第一部分是了解使用 gdb 调试 xv6（我使用的是 Debian）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中一个窗口启动 qemu-gdb</span></span><br><span class="line">cd xv6-labs-2023</span><br><span class="line">make qemu-gdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新开另一个窗口，连接 gdb</span></span><br><span class="line">cd xv6-labs-2023</span><br><span class="line">gdb-multiarch</span><br></pre></td></tr></table></figure>

<p> xv6 项目，为我们提供了便捷的 <code>.gdbinit</code> 脚本，默认情况下（下图）， GDB 好像不为我们自动加载这个脚本，<br><img   src="/../img/1708328101386-4416f785-08b3-481e-8d6a-618828bfe114.png"  alt="image.png"></p>
<p>有两种方式可以让图中的提示消失，<br>第一种是将 xv6 的 .gdbinit 文件设置为 auto-load</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/.config/gdb</span><br><span class="line">echo &quot;add-auto-load-safe-path /root/xv6-labs-2023/.gdbinit&quot; &gt; /root/.config/gdb/gdbinit</span><br></pre></td></tr></table></figure>
<p>第二种是直接执行 <code>source .gdbinit</code> 手动加载，第一种设置 auto-load 的方式一劳永逸，下次 gdb 的时候，不用敲 source 了。</p>
<p><img   src="/../img/1708328293952-be1287b8-996a-465d-af29-a8122c891b13.png"  alt="image.png"></p>
<p>下面查看一下.<code>gdbinit</code> 里写了什么，打开 <code>.gdbinit </code>发现它会帮我们，</p>
<ul>
<li>设置远端机器的架构 set architecture</li>
<li>自动连接远端机器 target remote</li>
<li>加载调试符号等操作 symbol-file</li>
<li>其他</li>
</ul>
<p>这些配置对于 GDB 远端调试都是必要的。特别解释一下 set architecture 的原因，现在市面上没有厂家量产 riscv 架构的机器，我们通常都是用 x86&#x2F;aarch64 架构，存在一个跨架构调试的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set confirm off</span><br><span class="line">set architecture riscv:rv64</span><br><span class="line">target remote 127.0.0.1:1234</span><br><span class="line">symbol-file kernel/kernel</span><br><span class="line">set disassemble-next-line auto</span><br><span class="line">set riscv use-compressed-breakpoints yes</span><br></pre></td></tr></table></figure>

<h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><h3 id="如何创建一个-syscall"><a href="#如何创建一个-syscall" class="headerlink" title="如何创建一个 syscall"></a>如何创建一个 syscall</h3><p><code>user/user.h</code> 中添加系统调用定义<br><code>user/usys.pl </code>中定义系统调用的入口，usys.pl 是一个脚本，会将所有的系统调用 entry 生成和对应的汇编 usys.S，将系统调用号存到 a7 寄存器，然后调用 ecall 指令进行系统调用，接着返回</p>
<blockquote>
<p>.global trace<br>trace:<br> li a7, SYS_trace<br> ecall<br> ret</p>
</blockquote>
<p><code>kernel/syscall.h</code> 中新增一个新的系统调用号。<br><code>kernel/syscall.c</code> 中 syscalls 数组新增 syscall 的响应函数，会在 syscall() 函数中以函数指针的方式被使用。<br><code>kernel/sysproc.c </code>中新增对应 syscall 的实际响应函数。以 sys_ 开头。 sys_ 开头的函数是个包装函数，先对应的寄存器中读取系统调用的参数，然后调用实际的函数完成系统调用。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>先在 struct proc (代表进程 process) 中添加 tracemask 字段，代表当前进程需要跟踪的 syscall。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/proc.h b/kernel/proc.h</span></span><br><span class="line"><span class="comment">index d021857..028a13a 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.h</span></span><br><span class="line"><span class="meta">@@ -91,6 +91,7 @@</span> struct proc &#123;</span><br><span class="line">   int killed;                  // If non-zero, have been killed</span><br><span class="line">   int xstate;                  // Exit status to be returned to parent&#x27;s wait</span><br><span class="line">   int pid;                     // Process ID</span><br><span class="line"><span class="addition">+  int tracemask;               // trace mask syscall ID</span></span><br></pre></td></tr></table></figure>

<p>当进程发起 syscall 时，会检测当前进程的发起的 syscall 的 tracemask 是否被置位。置位则代表当前进程被 trace，输出当前发起 syscall 进程的 pid，syscall_name，syscall 返回值。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -139,6 +167,9 @@</span> syscall(void)</span><br><span class="line">     // Use num to lookup the system call function for num, call it,</span><br><span class="line">     // and store its return value in p-&gt;trapframe-&gt;a0</span><br><span class="line">     p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"><span class="addition">+    if(p-&gt;tracemask &amp; (1 &lt;&lt; num)) &#123;</span></span><br><span class="line"><span class="addition">+      printf(&quot;%d: syscall %s -&gt; %d\n&quot;, p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     printf(&quot;%d %s: unknown sys call %d\n&quot;,</span><br><span class="line">             p-&gt;pid, p-&gt;name, num);</span><br></pre></td></tr></table></figure>

<h3 id="调用路径"><a href="#调用路径" class="headerlink" title="调用路径"></a>调用路径</h3><p>用户态同名函数 trace -&gt; syscall -&gt; sys_trace -&gt; 内核态同名函数 trace</p>
<ul>
<li>trace(userspace)：发起 syscall</li>
<li>syscall：系统调用函数，通过 syscalls 数组中定义的函数指针，根据系统调用号获得对应的函数指针，调用对应的 sys_ 函数</li>
<li>sys_trace：包装函数，先通过寄存器读取用户态传入的系统调用参数，接着调用实际的 trace()</li>
<li>trace(kernelspace)：设置当前进程的 tracemask 值为要追踪的系统调用号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> syscall_id;</span><br><span class="line"></span><br><span class="line">    argint(<span class="number">0</span>, &amp;syscall_id);</span><br><span class="line">    trace(syscall_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trace syscall</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> syscall_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    p-&gt;tracemask = syscall_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tracemask-变量初始化、销毁"><a href="#tracemask-变量初始化、销毁" class="headerlink" title="tracemask 变量初始化、销毁"></a>tracemask 变量初始化、销毁</h3><p>在 <code>struct proc</code> 新增了 tracemask 字段需要正确初始化以及销毁，fork 也需要复制将字段复制到子进程里才能符合 fork 的语义。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/proc.c b/kernel/proc.c</span></span><br><span class="line"><span class="comment">index 58a8a0b..c646f82 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.c</span></span><br><span class="line"><span class="meta">@@ -163,6 +163,7 @@</span> freeproc(struct proc *p)</span><br><span class="line">   p-&gt;pagetable = 0;</span><br><span class="line">   p-&gt;sz = 0;</span><br><span class="line">   p-&gt;pid = 0;</span><br><span class="line"><span class="addition">+  p-&gt;tracemask = 0;</span></span><br><span class="line">   p-&gt;parent = 0;</span><br><span class="line">   p-&gt;name[0] = 0;</span><br><span class="line">   p-&gt;chan = 0;</span><br><span class="line"><span class="meta">@@ -311,6 +312,7 @@</span> fork(void)</span><br><span class="line">   safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));</span><br><span class="line"></span><br><span class="line">   pid = np-&gt;pid;</span><br><span class="line"><span class="addition">+  np-&gt;tracemask = p-&gt;tracemask;</span></span><br><span class="line"></span><br><span class="line">   release(&amp;np-&gt;lock);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h3><p>Talk is cheap. Show me the code.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/Makefile b/Makefile</span></span><br><span class="line"><span class="comment">index 365c91b..ccf335b 100644</span></span><br><span class="line"><span class="comment">--- a/Makefile</span></span><br><span class="line"><span class="comment">+++ b/Makefile</span></span><br><span class="line"><span class="meta">@@ -188,6 +188,7 @@</span> UPROGS=\</span><br><span class="line"> 	$U/_grind\</span><br><span class="line"> 	$U/_wc\</span><br><span class="line"> 	$U/_zombie\</span><br><span class="line"><span class="addition">+	$U/_trace\</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/kernel/defs.h b/kernel/defs.h</span></span><br><span class="line"><span class="comment">index a3c962b..9d10bf3 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/defs.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/defs.h</span></span><br><span class="line"><span class="meta">@@ -106,6 +106,7 @@</span> void            yield(void);</span><br><span class="line"> int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><br><span class="line"> int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><br><span class="line"> void            procdump(void);</span><br><span class="line"><span class="addition">+int             trace(int);</span></span><br><span class="line"> </span><br><span class="line"> // swtch.S</span><br><span class="line"> void            swtch(struct context*, struct context*);</span><br><span class="line"><span class="comment">diff --git a/kernel/proc.c b/kernel/proc.c</span></span><br><span class="line"><span class="comment">index 58a8a0b..c646f82 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.c</span></span><br><span class="line"><span class="meta">@@ -163,6 +163,7 @@</span> freeproc(struct proc *p)</span><br><span class="line">   p-&gt;pagetable = 0;</span><br><span class="line">   p-&gt;sz = 0;</span><br><span class="line">   p-&gt;pid = 0;</span><br><span class="line"><span class="addition">+  p-&gt;tracemask = 0;</span></span><br><span class="line">   p-&gt;parent = 0;</span><br><span class="line">   p-&gt;name[0] = 0;</span><br><span class="line">   p-&gt;chan = 0;</span><br><span class="line"><span class="meta">@@ -311,6 +312,7 @@</span> fork(void)</span><br><span class="line">   safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));</span><br><span class="line"> </span><br><span class="line">   pid = np-&gt;pid;</span><br><span class="line"><span class="addition">+  np-&gt;tracemask = p-&gt;tracemask;</span></span><br><span class="line"> </span><br><span class="line">   release(&amp;np-&gt;lock);</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -627,6 +629,19 @@</span> killed(struct proc *p)</span><br><span class="line">   return k;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+// trace syscall</span></span><br><span class="line"><span class="addition">+int</span></span><br><span class="line"><span class="addition">+trace(int syscall_id)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  struct proc *p = myproc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  p-&gt;tracemask = syscall_id;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // Copy to either a user address, or kernel address,</span><br><span class="line"> // depending on usr_dst.</span><br><span class="line"> // Returns 0 on success, -1 on error.</span><br><span class="line"><span class="comment">diff --git a/kernel/proc.h b/kernel/proc.h</span></span><br><span class="line"><span class="comment">index d021857..028a13a 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.h</span></span><br><span class="line"><span class="meta">@@ -91,6 +91,7 @@</span> struct proc &#123;</span><br><span class="line">   int killed;                  // If non-zero, have been killed</span><br><span class="line">   int xstate;                  // Exit status to be returned to parent&#x27;s wait</span><br><span class="line">   int pid;                     // Process ID</span><br><span class="line"><span class="addition">+  int tracemask;               // trace mask syscall ID</span></span><br><span class="line"> </span><br><span class="line">   // wait_lock must be held when using this:</span><br><span class="line">   struct proc *parent;         // Parent process</span><br><span class="line"><span class="comment">diff --git a/kernel/syscall.c b/kernel/syscall.c</span></span><br><span class="line"><span class="comment">index ed65409..bf84a9c 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/syscall.c</span></span><br><span class="line"><span class="meta">@@ -101,6 +101,7 @@</span> extern uint64 sys_unlink(void);</span><br><span class="line"> extern uint64 sys_link(void);</span><br><span class="line"> extern uint64 sys_mkdir(void);</span><br><span class="line"> extern uint64 sys_close(void);</span><br><span class="line"><span class="addition">+extern uint64 sys_trace(void);</span></span><br><span class="line"> </span><br><span class="line"> // An array mapping syscall numbers from syscall.h</span><br><span class="line"> // to the function that handles the system call.</span><br><span class="line"><span class="meta">@@ -126,6 +127,33 @@</span> static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line"> [SYS_link]    sys_link,</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line"><span class="addition">+[SYS_trace]   sys_trace,</span></span><br><span class="line"><span class="addition">+&#125;;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+// Array of syscall name</span></span><br><span class="line"><span class="addition">+static char *syscall_name[]= &#123;</span></span><br><span class="line"><span class="addition">+[SYS_fork]    &quot;fork&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_exit]    &quot;exit&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_wait]    &quot;wait&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_pipe]    &quot;pipe&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_read]    &quot;read&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_kill]    &quot;kill&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_exec]    &quot;exec&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_fstat]   &quot;fstat&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_chdir]   &quot;chdir&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_dup]     &quot;dup&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_getpid]  &quot;getpid&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_sbrk]    &quot;sbrk&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_sleep]   &quot;sleep&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_uptime]  &quot;uptime&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_open]    &quot;open&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_write]   &quot;write&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_mknod]   &quot;mknod&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_unlink]  &quot;unlink&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_link]    &quot;link&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_mkdir]   &quot;mkdir&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_close]   &quot;close&quot;,</span></span><br><span class="line"><span class="addition">+[SYS_trace]   &quot;trace&quot;,</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> void</span><br><span class="line"><span class="meta">@@ -139,6 +167,9 @@</span> syscall(void)</span><br><span class="line">     // Use num to lookup the system call function for num, call it,</span><br><span class="line">     // and store its return value in p-&gt;trapframe-&gt;a0</span><br><span class="line">     p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"><span class="addition">+    if(p-&gt;tracemask &amp; (1 &lt;&lt; num)) &#123;</span></span><br><span class="line"><span class="addition">+      printf(&quot;%d: syscall %s -&gt; %d\n&quot;, p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     printf(&quot;%d %s: unknown sys call %d\n&quot;,</span><br><span class="line">             p-&gt;pid, p-&gt;name, num);</span><br><span class="line"><span class="comment">diff --git a/kernel/syscall.h b/kernel/syscall.h</span></span><br><span class="line"><span class="comment">index bc5f356..cc112b9 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/syscall.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/syscall.h</span></span><br><span class="line"><span class="meta">@@ -20,3 +20,4 @@</span></span><br><span class="line"> #define SYS_link   19</span><br><span class="line"> #define SYS_mkdir  20</span><br><span class="line"> #define SYS_close  21</span><br><span class="line"><span class="addition">+#define SYS_trace  22</span></span><br><span class="line"><span class="comment">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">index 3b4d5bd..2804c7d 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/sysproc.c</span></span><br><span class="line"><span class="meta">@@ -91,3 +91,12 @@</span> sys_uptime(void)</span><br><span class="line">   release(&amp;tickslock);</span><br><span class="line">   return xticks;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+uint64</span></span><br><span class="line"><span class="addition">+sys_trace(void) &#123;</span></span><br><span class="line"><span class="addition">+  int syscall_id;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  argint(0, &amp;syscall_id);</span></span><br><span class="line"><span class="addition">+  trace(syscall_id);</span></span><br><span class="line"><span class="addition">+  return 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="comment">diff --git a/user/user.h b/user/user.h</span></span><br><span class="line"><span class="comment">index 4d398d5..0bf4333 100644</span></span><br><span class="line"><span class="comment">--- a/user/user.h</span></span><br><span class="line"><span class="comment">+++ b/user/user.h</span></span><br><span class="line"><span class="meta">@@ -22,6 +22,7 @@</span> int getpid(void);</span><br><span class="line"> char* sbrk(int);</span><br><span class="line"> int sleep(int);</span><br><span class="line"> int uptime(void);</span><br><span class="line"><span class="addition">+int trace(int);</span></span><br><span class="line"> </span><br><span class="line"> // ulib.c</span><br><span class="line"> int stat(const char*, struct stat*);</span><br><span class="line"><span class="comment">diff --git a/user/usys.pl b/user/usys.pl</span></span><br><span class="line"><span class="comment">index 01e426e..9c97b05 100755</span></span><br><span class="line"><span class="comment">--- a/user/usys.pl</span></span><br><span class="line"><span class="comment">+++ b/user/usys.pl</span></span><br><span class="line"><span class="meta">@@ -36,3 +36,4 @@</span> sub entry &#123;</span><br><span class="line"> entry(&quot;sbrk&quot;);</span><br><span class="line"> entry(&quot;sleep&quot;);</span><br><span class="line"> entry(&quot;uptime&quot;);</span><br><span class="line"><span class="addition">+entry(&quot;trace&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>实现完 trace syscall 后，总觉得好像少点什么，不完整。仔细想想，我们实现的 trace 只能 trace 进程本身以及子进程？<br>Q： 那我们在现有的基础设施上，能否实现 trace 别的进程，也就是说给 trace 命令添加一个 -p 参数，能 trace 别的进程？<br>A： 实际上是可以的，而且在现有的基础设施上支持 -p 参数没有工作量，只需要重新实现 trace，将其中 myproc() 替换为遍历所有的进程，将其中某个 pid 进程的 tracemask 置位即可。</p>
<h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>实现一个 sysinfo 系统调用，获取 xv6 内核的空闲内存以及当前进程数，将数据从内核态拷贝到用户态。</p>
<h3 id="sysinfo-系统调用"><a href="#sysinfo-系统调用" class="headerlink" title="sysinfo 系统调用"></a>sysinfo 系统调用</h3><p>有两点需要注意，<br>第一点是向用户态拷贝数据时候，只需要将结构体的地址传进来，内核从首地址往后写数据，用户态收到数据后根据定义的结构体解析数据。所以，只需要一个地址 addr 就行了。<br>第二点是返回值，当 copyout 失败的时候，需要返回 -1。sysinfotest.c 里测试用例会构造一个错误的 addr 作为 sysinfo 的参数传进来，此时 sysinfo 会失败，测试用例会对比返回值是不是 <code>0xffffffffffffffff</code> ，也就是 -1 。这里涉及的是 C 语言负数的存储方式，补码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sysinfo syscall</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sysinfo</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    info.freemem = nr_freemem();</span><br><span class="line">    info.nproc = nr_processes();</span><br><span class="line"></span><br><span class="line">    ret = copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nr_freemem 和 nr_processes 两个函数的定义写在 kernel&#x2F;defs.h 就行了， xv6 内核态所有的函数定义都放在此文件里。</p>
<h3 id="获取空闲内存"><a href="#获取空闲内存" class="headerlink" title="获取空闲内存"></a>获取空闲内存</h3><p>xv6 的空闲内存使用链表管理的，通过将指针 r 指向当前 kmem.freelist 即空闲内存的头部，遍历直到访问为 NULL 时，期间访问的总数及空闲内存的个数。再乘上每页的大小可得空闲内存容量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nr_freemem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    uint64 amount = <span class="number">0</span>;</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="keyword">while</span>(r) &#123;</span><br><span class="line">        r= r-&gt;next;</span><br><span class="line">        amount +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> amount * PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取进程数"><a href="#获取进程数" class="headerlink" title="获取进程数"></a>获取进程数</h3><p>xv6 内核进程使用全局维护的 proc 数组来表示，遍历它即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nr_processes</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> nr_p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;state != UNUSED)</span><br><span class="line">            nr_p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nr_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Show-me-the-code-1"><a href="#Show-me-the-code-1" class="headerlink" title="Show me the code"></a>Show me the code</h3><p>Talk is cheap. Show me the code.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/Makefile b/Makefile</span></span><br><span class="line"><span class="comment">index ccf335b..0e12e1e 100644</span></span><br><span class="line"><span class="comment">--- a/Makefile</span></span><br><span class="line"><span class="comment">+++ b/Makefile</span></span><br><span class="line"><span class="meta">@@ -189,6 +189,7 @@</span> UPROGS=\</span><br><span class="line"> 	$U/_wc\</span><br><span class="line"> 	$U/_zombie\</span><br><span class="line"> 	$U/_trace\</span><br><span class="line"><span class="addition">+	$U/_sysinfotest\</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/kernel/defs.h b/kernel/defs.h</span></span><br><span class="line"><span class="comment">index 9d10bf3..5e2867a 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/defs.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/defs.h</span></span><br><span class="line"><span class="meta">@@ -63,6 +63,7 @@</span> void            ramdiskrw(struct buf*);</span><br><span class="line"> void*           kalloc(void);</span><br><span class="line"> void            kfree(void *);</span><br><span class="line"> void            kinit(void);</span><br><span class="line"><span class="addition">+int             nr_freemem(void);</span></span><br><span class="line"> </span><br><span class="line"> // log.c</span><br><span class="line"> void            initlog(int, struct superblock*);</span><br><span class="line"><span class="meta">@@ -107,6 +108,8 @@</span> int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><br><span class="line"> int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><br><span class="line"> void            procdump(void);</span><br><span class="line"> int             trace(int);</span><br><span class="line"><span class="addition">+int             sysinfo(uint64);</span></span><br><span class="line"><span class="addition">+int             nr_processes(void);</span></span><br><span class="line"> </span><br><span class="line"> // swtch.S</span><br><span class="line"> void            swtch(struct context*, struct context*);</span><br><span class="line"><span class="comment">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span></span><br><span class="line"><span class="comment">index 0699e7e..c953886 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/kalloc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/kalloc.c</span></span><br><span class="line"><span class="meta">@@ -80,3 +80,16 @@</span> kalloc(void)</span><br><span class="line">     memset((char*)r, 5, PGSIZE); // fill with junk</span><br><span class="line">   return (void*)r;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+int</span></span><br><span class="line"><span class="addition">+nr_freemem(void) &#123;</span></span><br><span class="line"><span class="addition">+  struct run *r;</span></span><br><span class="line"><span class="addition">+  uint64 amount = 0;</span></span><br><span class="line"><span class="addition">+  r = kmem.freelist;</span></span><br><span class="line"><span class="addition">+  while(r) &#123;</span></span><br><span class="line"><span class="addition">+    r= r-&gt;next;</span></span><br><span class="line"><span class="addition">+    amount +=1;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return amount * PGSIZE;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="comment">diff --git a/kernel/proc.c b/kernel/proc.c</span></span><br><span class="line"><span class="comment">index c646f82..3ddb18c 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.c</span></span><br><span class="line"><span class="meta">@@ -5,6 +5,7 @@</span></span><br><span class="line"> #include &quot;spinlock.h&quot;</span><br><span class="line"> #include &quot;proc.h&quot;</span><br><span class="line"> #include &quot;defs.h&quot;</span><br><span class="line"><span class="addition">+#include &quot;sysinfo.h&quot;</span></span><br><span class="line"> </span><br><span class="line"> struct cpu cpus[NCPU];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -641,6 +642,22 @@</span> trace(int syscall_id)</span><br><span class="line">   return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+// sysinfo syscall</span></span><br><span class="line"><span class="addition">+int</span></span><br><span class="line"><span class="addition">+sysinfo(uint64 addr)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  int ret;</span></span><br><span class="line"><span class="addition">+  struct sysinfo info;</span></span><br><span class="line"><span class="addition">+  struct proc *p = myproc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  info.freemem = nr_freemem();</span></span><br><span class="line"><span class="addition">+  info.nproc = nr_processes();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  ret = copyout(p-&gt;pagetable, addr, (char *)&amp;info, sizeof(info));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return ret &lt; 0 ? -1 : 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> </span><br><span class="line"> // Copy to either a user address, or kernel address,</span><br><span class="line"> // depending on usr_dst.</span><br><span class="line"><span class="meta">@@ -701,3 +718,16 @@</span> procdump(void)</span><br><span class="line">     printf(&quot;\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+int</span></span><br><span class="line"><span class="addition">+nr_processes(void) &#123;</span></span><br><span class="line"><span class="addition">+  struct proc *p;</span></span><br><span class="line"><span class="addition">+  int nr_p = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span></span><br><span class="line"><span class="addition">+      if(p-&gt;state != UNUSED)</span></span><br><span class="line"><span class="addition">+        nr_p++;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return nr_p;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="comment">diff --git a/kernel/syscall.c b/kernel/syscall.c</span></span><br><span class="line"><span class="comment">index bf84a9c..726635a 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/syscall.c</span></span><br><span class="line"><span class="meta">@@ -102,6 +102,7 @@</span> extern uint64 sys_link(void);</span><br><span class="line"> extern uint64 sys_mkdir(void);</span><br><span class="line"> extern uint64 sys_close(void);</span><br><span class="line"> extern uint64 sys_trace(void);</span><br><span class="line"><span class="addition">+extern uint64 sys_sysinfo(void);</span></span><br><span class="line"> </span><br><span class="line"> // An array mapping syscall numbers from syscall.h</span><br><span class="line"> // to the function that handles the system call.</span><br><span class="line"><span class="meta">@@ -128,6 +129,7 @@</span> static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line"> [SYS_trace]   sys_trace,</span><br><span class="line"><span class="addition">+[SYS_sysinfo] sys_sysinfo,</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> // Array of syscall name</span><br><span class="line"><span class="meta">@@ -154,6 +156,7 @@</span> static char *syscall_name[]= &#123;</span><br><span class="line"> [SYS_mkdir]   &quot;mkdir&quot;,</span><br><span class="line"> [SYS_close]   &quot;close&quot;,</span><br><span class="line"> [SYS_trace]   &quot;trace&quot;,</span><br><span class="line"><span class="addition">+[SYS_sysinfo] &quot;sysinfo&quot;,</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> void</span><br><span class="line"><span class="comment">diff --git a/kernel/syscall.h b/kernel/syscall.h</span></span><br><span class="line"><span class="comment">index cc112b9..7961890 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/syscall.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/syscall.h</span></span><br><span class="line"><span class="meta">@@ -21,3 +21,4 @@</span></span><br><span class="line"> #define SYS_mkdir  20</span><br><span class="line"> #define SYS_close  21</span><br><span class="line"> #define SYS_trace  22</span><br><span class="line"><span class="addition">+#define SYS_sysinfo  23</span></span><br><span class="line"><span class="comment">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">index 2804c7d..b36a4e0 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/sysproc.c</span></span><br><span class="line"><span class="meta">@@ -100,3 +100,14 @@</span> sys_trace(void) &#123;</span><br><span class="line">   trace(syscall_id);</span><br><span class="line">   return 0;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+uint64</span></span><br><span class="line"><span class="addition">+sys_sysinfo(void) &#123;</span></span><br><span class="line"><span class="addition">+  uint64 addr;</span></span><br><span class="line"><span class="addition">+  int ret;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  argaddr(0, &amp;addr);</span></span><br><span class="line"><span class="addition">+  ret = sysinfo(addr);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return ret &lt; 0 ? -1 : 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="comment">diff --git a/user/user.h b/user/user.h</span></span><br><span class="line"><span class="comment">index 0bf4333..1645956 100644</span></span><br><span class="line"><span class="comment">--- a/user/user.h</span></span><br><span class="line"><span class="comment">+++ b/user/user.h</span></span><br><span class="line"><span class="meta">@@ -1,4 +1,5 @@</span></span><br><span class="line"> struct stat;</span><br><span class="line"><span class="addition">+struct sysinfo;</span></span><br><span class="line"> </span><br><span class="line"> // system calls</span><br><span class="line"> int fork(void);</span><br><span class="line"><span class="meta">@@ -23,6 +24,7 @@</span> char* sbrk(int);</span><br><span class="line"> int sleep(int);</span><br><span class="line"> int uptime(void);</span><br><span class="line"> int trace(int);</span><br><span class="line"><span class="addition">+int sysinfo(struct sysinfo *);</span></span><br><span class="line"> </span><br><span class="line"> // ulib.c</span><br><span class="line"> int stat(const char*, struct stat*);</span><br><span class="line"><span class="comment">diff --git a/user/usys.pl b/user/usys.pl</span></span><br><span class="line"><span class="comment">index 9c97b05..bc109fd 100755</span></span><br><span class="line"><span class="comment">--- a/user/usys.pl</span></span><br><span class="line"><span class="comment">+++ b/user/usys.pl</span></span><br><span class="line"><span class="meta">@@ -37,3 +37,4 @@</span> sub entry &#123;</span><br><span class="line"> entry(&quot;sleep&quot;);</span><br><span class="line"> entry(&quot;uptime&quot;);</span><br><span class="line"> entry(&quot;trace&quot;);</span><br><span class="line"><span class="addition">+entry(&quot;sysinfo&quot;);</span></span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>最后 <code>make grade</code> 查看结果,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">== Test answers-syscall.txt ==</span><br><span class="line">answers-syscall.txt: OK</span><br><span class="line">== Test trace 32 grep ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">trace 32 grep: OK (3.0s)</span><br><span class="line">== Test trace all grep ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">trace all grep: OK (0.9s)</span><br><span class="line">== Test trace nothing ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">trace nothing: OK (0.8s)</span><br><span class="line">== Test trace children ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">trace children: OK (32.3s)</span><br><span class="line">== Test sysinfotest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">sysinfotest: OK (3.6s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 40/40</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
  </entry>
  <entry>
    <title>xv6 Lab3: page tables</title>
    <url>/xv6-lab3-page-tables.html</url>
    <content><![CDATA[<p>Page table 使用用来映射进程虚拟地址到物理地址。有了 pagetable 进程看到的是虚拟地址，对操作系统来说，有了 pagetable，可以实现更多的管理面的控制，Isolating，Guarding and etc.</p>
<h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>加速  <code>sys_getpid</code> 这个系统调用。资源抽象有很多维度，我们内核对外提供服务的抽象就是 proc (process 的缩写）。而 proc 是 xv6 内核提供的抽象，其标识符就是 pid。也就是说 pid 是内核能看到的，用户态向获取自身的 pid 只能通过 syscall 来实现。proc 的 pid 是放在内核页里的，用户态看不到，我们加速 getpid syscall 的思路很简单，将 pid 保存到用户态页就行了。</p>
<p>Linux 内核获取时间的系统调用 <code>gettimeofday()</code> 也是这个思路，在用户态映射一个只读的页，里面存储时间。在 Linux 上这种优化手段叫做 vsyscall&#x2F;vdso,</p>
<p><img   src="/../img/linux-vdso-speed.png"  alt="Linux vdso speed up"></p>
<p>xv6 里，我们这个页叫做 USYSCALL，被安排放在 TRAPFRAME 页的下一页。既然，USYSCALL 这个页已经映射到用户态，那么获取 pid 的 syscall 也要在用户态实现一遍了。xv6 里，是实现在了 ulibc 里。</p>
<p>这种加速思路还可以用来加速各种各样的 syscall，USYSCALL 这个页有 4k 大小。现在只使用了一个 int 字段。还有很多空间放置其他字段可以用于加速其他 syscall</p>
<h3 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/proc.c b/kernel/proc.c</span></span><br><span class="line"><span class="comment">index 58a8a0b..cf059d3 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.c</span></span><br><span class="line"><span class="meta">@@ -132,6 +132,14 @@</span> allocproc(void)</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  // Allocate a USYSCALL page.</span></span><br><span class="line"><span class="addition">+  if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0)&#123;</span></span><br><span class="line"><span class="addition">+    freeproc(p);</span></span><br><span class="line"><span class="addition">+    release(&amp;p-&gt;lock);</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   // An empty user page table.</span><br><span class="line">   p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">   if(p-&gt;pagetable == 0)&#123;</span><br><span class="line"><span class="meta">@@ -158,6 +166,9 @@</span> freeproc(struct proc *p)</span><br><span class="line">   if(p-&gt;trapframe)</span><br><span class="line">     kfree((void*)p-&gt;trapframe);</span><br><span class="line">   p-&gt;trapframe = 0;</span><br><span class="line"><span class="addition">+  if(p-&gt;usyscall)</span></span><br><span class="line"><span class="addition">+    kfree((void*)p-&gt;usyscall);</span></span><br><span class="line"><span class="addition">+  p-&gt;usyscall = 0;</span></span><br><span class="line">   if(p-&gt;pagetable)</span><br><span class="line">     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">   p-&gt;pagetable = 0;</span><br><span class="line"><span class="meta">@@ -202,6 +213,15 @@</span> proc_pagetable(struct proc *p)</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  // map the USYSCALL page just below the TRAMPOLINE page, for</span></span><br><span class="line"><span class="addition">+  // fast syscall.</span></span><br><span class="line"><span class="addition">+  if(mappages(pagetable, USYSCALL, PGSIZE,</span></span><br><span class="line"><span class="addition">+              (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; 0)&#123;</span></span><br><span class="line"><span class="addition">+    uvmunmap(pagetable, USYSCALL, 1, 0);</span></span><br><span class="line"><span class="addition">+    uvmfree(pagetable, 0);</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   return pagetable;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -212,6 +232,7 @@</span> proc_freepagetable(pagetable_t pagetable, uint64 sz)</span><br><span class="line"> &#123;</span><br><span class="line">   uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><br><span class="line">   uvmunmap(pagetable, TRAPFRAME, 1, 0);</span><br><span class="line"><span class="addition">+  uvmunmap(pagetable, USYSCALL, 1, 0);</span></span><br><span class="line">   uvmfree(pagetable, sz);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/kernel/proc.h b/kernel/proc.h</span></span><br><span class="line"><span class="comment">index d021857..155da44 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.h</span></span><br><span class="line"><span class="meta">@@ -100,6 +100,7 @@</span> struct proc &#123;</span><br><span class="line">   uint64 sz;                   // Size of process memory (bytes)</span><br><span class="line">   pagetable_t pagetable;       // User page table</span><br><span class="line">   struct trapframe *trapframe; // data page for trampoline.S</span><br><span class="line"><span class="addition">+  struct usyscall *usyscall;    // page for fast syscall</span></span><br><span class="line">   struct context context;      // swtch() here to run process</span><br><span class="line">   struct file *ofile[NOFILE];  // Open files</span><br><span class="line">   struct inode *cwd;           // Current directory</span><br></pre></td></tr></table></figure>

<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><h3 id="为什么-pagetable-是-3-层？"><a href="#为什么-pagetable-是-3-层？" class="headerlink" title="为什么 pagetable 是 3 层？"></a>为什么 pagetable 是 3 层？</h3><p>硬件设计使然，看 xv6-book 里面的解释</p>
<blockquote>
<p>As Figure 3.2 shows, a RISC-V CPU translates a virtual address into a physical in three steps. A page table is stored in physical memory as a three-level tree. The root of the tree is a 4096-byte page-table page that contains 512 PTEs, which contain the physical addresses for page-table pages in the next level of the tree. Each of those pages contains 512 PTEs for the final level in the tree. The paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page, the middle 9 bits to select a PTE in a page-table page in the next level of the tree, and the bottom 9 bits to select the final PTE. (In Sv48 RISC-V a page table has four levels, and bits 39 through 47 of a virtual address index into the top-level.)</p>
</blockquote>
<p>需要注意的是当 PTE (pagetable entry) 的 r&#x2F;w&#x2F;x 均没有置位的时候，代表指向的是下一级 pagetable。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Show-me-the-code-1"><a href="#Show-me-the-code-1" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/defs.h b/kernel/defs.h</span></span><br><span class="line"><span class="comment">index a3c962b..bdbd654 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/defs.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/defs.h</span></span><br><span class="line"><span class="meta">@@ -173,6 +173,7 @@</span> uint64          walkaddr(pagetable_t, uint64);</span><br><span class="line"> int             copyout(pagetable_t, uint64, char *, uint64);</span><br><span class="line"> int             copyin(pagetable_t, char *, uint64, uint64);</span><br><span class="line"> int             copyinstr(pagetable_t, char *, uint64, uint64);</span><br><span class="line"><span class="addition">+void            vmprint(pagetable_t pagetable);</span></span><br><span class="line"> </span><br><span class="line"> // plic.c</span><br><span class="line"> void            plicinit(void);</span><br><span class="line"><span class="comment">diff --git a/kernel/exec.c b/kernel/exec.c</span></span><br><span class="line"><span class="comment">index e18bbb6..b5adef2 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/exec.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/exec.c</span></span><br><span class="line"><span class="meta">@@ -128,6 +128,11 @@</span> exec(char *path, char **argv)</span><br><span class="line">   p-&gt;trapframe-&gt;sp = sp; // initial stack pointer</span><br><span class="line">   proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  // print pagetable</span></span><br><span class="line"><span class="addition">+  if(p-&gt;pid == 1) &#123;</span></span><br><span class="line"><span class="addition">+    vmprint(pagetable);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   return argc; // this ends up in a0, the first argument to main(argc, argv)</span><br><span class="line"> </span><br><span class="line">  bad:</span><br><span class="line"><span class="comment">diff --git a/kernel/vm.c b/kernel/vm.c</span></span><br><span class="line"><span class="comment">index 5c31e87..0d7338d 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/vm.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/vm.c</span></span><br><span class="line"><span class="meta">@@ -449,3 +449,29 @@</span> copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)</span><br><span class="line">     return -1;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void pte_print_walk(pagetable_t pagetable, int level) &#123;</span></span><br><span class="line"><span class="addition">+	// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line"><span class="addition">+	for (int i = 0; i &lt; 512; i++) &#123;</span></span><br><span class="line"><span class="addition">+		pte_t pte = pagetable[i];</span></span><br><span class="line"><span class="addition">+		if (!(pte &amp; PTE_V)) &#123;</span></span><br><span class="line"><span class="addition">+			continue;</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		for (int i = 0; i &lt;= level; i++) &#123;</span></span><br><span class="line"><span class="addition">+			printf(&quot;..&quot;);</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"><span class="addition">+		printf(&quot;%d: pte %p pa %p\n&quot;, i, pte, PTE2PA(pte));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if ((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0) &#123;</span></span><br><span class="line"><span class="addition">+			// this PTE points to a lower-level page table.</span></span><br><span class="line"><span class="addition">+			uint64 child = PTE2PA(pte);</span></span><br><span class="line"><span class="addition">+			pte_print_walk((pagetable_t)child, level + 1);</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void vmprint(pagetable_t pagetable) &#123;</span></span><br><span class="line"><span class="addition">+	printf(&quot;page table %p\n&quot;, pagetable);</span></span><br><span class="line"><span class="addition">+	pte_print_walk(pagetable, 0);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>查看 xv6-book ，其中 Figure 3.2 写了 RISC-V 的 Paging(换页) 的细节。<br>其中 bit 6 就是本次实验要用的 access bit。<br><img   src="/../img/1710949515204-e21356df-78c2-4507-b6a8-256088296112.png"  alt="image.png"></p>
<p>根据最后的实现，我们只声明了 pte 的 bit 6 为 PTE_A, 但并没有看到任何的置位代码。所以，PTE_A 应该是硬件(CPU)置位. 因为 xv6 里 paging 是硬件实现的，置位自然也是硬件做。</p>
<h3 id="Show-me-the-code-2"><a href="#Show-me-the-code-2" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/riscv.h b/kernel/riscv.h</span></span><br><span class="line"><span class="comment">index 20a01db..100895e 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/riscv.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/riscv.h</span></span><br><span class="line"><span class="meta">@@ -343,6 +343,7 @@</span> typedef uint64 *pagetable_t; // 512 PTEs</span><br><span class="line"> #define PTE_W (1L &lt;&lt; 2)</span><br><span class="line"> #define PTE_X (1L &lt;&lt; 3)</span><br><span class="line"> #define PTE_U (1L &lt;&lt; 4) // user can access</span><br><span class="line"><span class="addition">+#define PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line"> </span><br><span class="line"> // shift a physical address to the right place for a PTE.</span><br><span class="line"> #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span><br><span class="line"><span class="comment">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">index 88644b2..296935f 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/sysproc.c</span></span><br><span class="line"><span class="meta">@@ -71,11 +71,36 @@</span> sys_sleep(void)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #ifdef LAB_PGTBL</span><br><span class="line"><span class="deletion">-int</span></span><br><span class="line"><span class="deletion">-sys_pgaccess(void)</span></span><br><span class="line"><span class="deletion">-&#123;</span></span><br><span class="line"><span class="deletion">-  // lab pgtbl: your code here.</span></span><br><span class="line"><span class="deletion">-  return 0;</span></span><br><span class="line"><span class="addition">+int sys_pgaccess(void) &#123;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uint64 baseaddr;</span></span><br><span class="line"><span class="addition">+	int upper;</span></span><br><span class="line"><span class="addition">+	uint64 outaddr;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uint64 va;</span></span><br><span class="line"><span class="addition">+	pte_t *pte;</span></span><br><span class="line"><span class="addition">+	uint64 abits = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	argaddr(0, &amp;baseaddr);</span></span><br><span class="line"><span class="addition">+	argint(1, &amp;upper);</span></span><br><span class="line"><span class="addition">+	argaddr(2, &amp;outaddr);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	struct proc *p = myproc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	for (int i = 0; i &lt; upper; i++) &#123;</span></span><br><span class="line"><span class="addition">+		va = baseaddr + i * PGSIZE;</span></span><br><span class="line"><span class="addition">+		pte = walk(p-&gt;pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (*pte &amp; PTE_A) &#123;</span></span><br><span class="line"><span class="addition">+			abits = abits | (1 &lt;&lt; i); // set bit</span></span><br><span class="line"><span class="addition">+			*pte = (*pte) &amp; (~PTE_A); // reset PTE_A</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (copyout(p-&gt;pagetable, outaddr, (char *)&amp;abits, sizeof(abits)) &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"> &#125;</span><br><span class="line"> #endif</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>最后，<code>make grade</code> 查看结果，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">== Test pgtbltest ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(3.8s)</span><br><span class="line">== Test   pgtbltest: ugetpid ==</span><br><span class="line">  pgtbltest: ugetpid: OK</span><br><span class="line">== Test   pgtbltest: pgaccess ==</span><br><span class="line">  pgtbltest: pgaccess: OK</span><br><span class="line">== Test pte printout ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">pte printout: OK (0.7s)</span><br><span class="line">== Test answers-pgtbl.txt ==</span><br><span class="line">answers-pgtbl.txt: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(141.1s)</span><br><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 46/46</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、<a class="link"   href="https://pdos.csail.mit.edu/6.828/2023/lec/l-QA1_2.pdf" >6.181: Q&amp;A Labs (PGTBL) 2023<i class="fas fa-external-link-alt"></i></a></p>
<p>2、<a class="link"   href="https://lwn.net/Articles/615809" >Implementing virtual system calls<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
  </entry>
  <entry>
    <title>xv6 Lab4: Traps</title>
    <url>/xv6-lab4-traps.html</url>
    <content><![CDATA[<p>Lab4 实现用户态 trap 处理，集中在返回用户态的中断上下文保存，很类似 signal 处理。</p>
<h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><p>主要是一些基础知识。</p>
<blockquote>
<p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?</p>
</blockquote>
<p>根据 xv6 传参规范， a1,a2 分别存放第一个参数和第二个参数。故  13 在 a2，另外通过 call.asm 也能看出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%d %d\n&quot;, f(8) + 1, 13);</span><br><span class="line">    24:	4635                	li	a2,13</span><br><span class="line">    26:	45b1                	li	a1,12</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</p>
</blockquote>
<p>000000000000000e <f><br>0000000000000000 <g></p>
<blockquote>
<p>At what address is the function printf located?</p>
</blockquote>
<p>0000000000000630 </p>
<blockquote>
<p>What value is in the register ra just after the jalr to printf in main?</p>
</blockquote>
<p>0x38<br>讲义里介绍，ra 存储的是下一条指令的地址。所以就是,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit(0);</span><br><span class="line">    38:	4501                	li	a0,0</span><br></pre></td></tr></table></figure>

<p>Ref: <a class="link"   href="https://pdos.csail.mit.edu/6.1810/2023/lec/l-riscv.txt#:~:text=ra%20%3C%2D%20address%20of%20next%20instruction" >https://pdos.csail.mit.edu/6.1810/2023/lec/l-riscv.txt#:~:text&#x3D;ra &lt;- address of next instruction<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>Run the following code.<br>unsigned int i &#x3D; 0x00646c72;<br>printf(“H%x Wo%s”, 57616, &amp;i);<br>What is the output? Here’s an ASCII table that maps bytes to characters.<br>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</p>
</blockquote>
<p>输出是 “HE110 World”<br>如果是大段序，i &#x3D; 0x726c64</p>
<p>下面解释输出为什么是 E110 和 rld？<br><strong>为什么是 rld?</strong><br>16 进制字符是 2 组 2 组一读，根据链接里的对照表，我们将 0x00646c72 翻译为 dlr,<br>因为是小端，所以时间上 CPU 从小端往大端读，也就是 rld.<br>00 -&gt; null<br>64 -&gt; ‘d’<br>6c -&gt; ‘l’<br>72 -&gt; ‘r’<br><strong>为什么是 E110?</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3</span><br><span class="line">&gt;&gt;&gt; hex(57616)</span><br><span class="line">&#x27;0xe110&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In the following code, what is going to be printed after ‘y&#x3D;’? (note: the answer is not a specific value.) Why does this happen?</p>
</blockquote>
<p>打印的是 a2 寄存器的值</p>
<h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>做这个任务前需要先理解 RISC-V 的  <a class="link"   href="https://pdos.csail.mit.edu/6.828/2023/lec/l-riscv.txt" >Calling conventions<i class="fas fa-external-link-alt"></i></a> (调用约定) ，理解了 calling conventions 实现 backtrace 就显得很简单～</p>
<p>函数调用通常都是压栈，栈是从高处往低处增长，图中展示每一个函数的压栈情况，依次压栈的是”函数返回地址”，”fp”，”寄存器”，”本地变量”等<br>然后就是被调用函数以同样的次序压栈，函数调用会依次压栈下去。<br><code>$fp</code> 寄存器指向的当前函数的栈帧<br><code>$sp</code> 寄存器指向的是栈顶，在 backtrace 里，我们不需要它。</p>
<p><strong>下面这张图很重要，代表 RISC-V 函数调用过程中的压栈操作，也就是函数的栈帧(fucntion frame)</strong></p>
<p><img   src="/../img/risc-v-stack-frame.png"  alt="function call stack frame"></p>
<p><a class="link"   href="https://pdos.csail.mit.edu/6.828/2023/lec/l-riscv.txt" >https://pdos.csail.mit.edu/6.828/2023/lec/l-riscv.txt<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="关键实现"><a href="#关键实现" class="headerlink" title="关键实现"></a>关键实现</h3><p>1、<code>kernel/riscv.h</code>: 实现一个获取当前 frame pointer 的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    uint64 x;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、实现栈回溯</p>
<p><code>kernel/memlayout.h</code> 里描述了 xv6 内核的 stack 的大小，KSTACK(p) 的参数 p 代表是一个 proc，一个 进程，xv6 里，每个进程的 KSTACK 占用 2 个 PGSIZE 大小，其中一个内核栈，另一个是 GUARD PAGE，用于检测栈溢出的，防止“爆栈”后污染别的进程地址空间。<br>所以，xv6 每个进程的的内核栈大小都是一个 PAGE（4K）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p) + 1) * 2 * PGSIZE)</span></span><br></pre></td></tr></table></figure>

<p>在了解内核栈后。实现对一个进程的 backtrace，就显得很简单。<br>首先获取当前 fp，这个 fp 指向内核栈的某个地址。使用 <code>PGROUNDUP</code> 获得页的上界（因为栈是从高往低处增长，所以向上取基址，最上面的是栈底），通过 fp 之间的指向进行回溯。</p>
<ul>
<li>当前 fp 减 8 就是返回地址所在栈帧（frame）地址，解引用地址就获得 return address。</li>
<li>将 fp 减 16 地址的内容解引用获得就是 caller fp。</li>
</ul>
<p>看上图，return address 的位置就在 fp 的下面，通过 fp-8 访问。previous fp 在 return address 的下面，通过 fp - 16 访问，还有函数参数等均可以通过 fp 相对位置计算出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 retaddr;</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  uint64 top = PGROUNDUP(fp);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fp &lt; top) &#123;</span><br><span class="line">    retaddr = *(uint64 *)(fp - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, retaddr);</span><br><span class="line"></span><br><span class="line">    fp = *(uint64 *)(fp - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/defs.h b/kernel/defs.h</span></span><br><span class="line"><span class="comment">index f3f5fef..3dface5 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/defs.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/defs.h</span></span><br><span class="line"><span class="meta">@@ -147,6 +147,7 @@</span> void trapinit(void);</span><br><span class="line"> void trapinithart(void);</span><br><span class="line"> extern struct spinlock tickslock;</span><br><span class="line"> void usertrapret(void);</span><br><span class="line"><span class="addition">+void backtrace();</span></span><br><span class="line"> </span><br><span class="line"> // uart.c</span><br><span class="line"> void uartinit(void);</span><br><span class="line"><span class="comment">diff --git a/kernel/printf.c b/kernel/printf.c</span></span><br><span class="line"><span class="comment">index 9171d09..0f901d1 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/printf.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/printf.c</span></span><br><span class="line"><span class="meta">@@ -122,6 +122,7 @@</span> panic(char *s)</span><br><span class="line">   printf(&quot;panic: &quot;);</span><br><span class="line">   printf(s);</span><br><span class="line">   printf(&quot;\n&quot;);</span><br><span class="line"><span class="addition">+  backtrace();</span></span><br><span class="line">   panicked = 1; // freeze uart output from other CPUs</span><br><span class="line">   for (;;)</span><br><span class="line">     ;</span><br><span class="line"><span class="comment">diff --git a/kernel/riscv.h b/kernel/riscv.h</span></span><br><span class="line"><span class="comment">index 4bb2f3a..16ca148 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/riscv.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/riscv.h</span></span><br><span class="line"><span class="meta">@@ -319,6 +319,14 @@</span> r_ra()</span><br><span class="line">   return x;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+static inline uint64</span></span><br><span class="line"><span class="addition">+r_fp()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  uint64 x;</span></span><br><span class="line"><span class="addition">+  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span></span><br><span class="line"><span class="addition">+  return x;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // flush the TLB.</span><br><span class="line"> static inline void</span><br><span class="line"> sfence_vma()</span><br><span class="line"><span class="comment">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">index 7990c27..0cd201d 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/sysproc.c</span></span><br><span class="line"><span class="meta">@@ -54,6 +54,8 @@</span> sys_sleep(void)</span><br><span class="line">   int n;</span><br><span class="line">   uint ticks0;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  backtrace();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   argint(0, &amp;n);</span><br><span class="line">   if (n &lt; 0)</span><br><span class="line">     n = 0;</span><br><span class="line"><span class="comment">diff --git a/kernel/trap.c b/kernel/trap.c</span></span><br><span class="line"><span class="comment">index f30d2e3..0dcd358 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/trap.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/trap.c</span></span><br><span class="line"><span class="meta">@@ -223,3 +223,19 @@</span> devintr()</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void</span></span><br><span class="line"><span class="addition">+backtrace()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  uint64 retaddr;</span></span><br><span class="line"><span class="addition">+  uint64 fp = r_fp();</span></span><br><span class="line"><span class="addition">+  uint64 top = PGROUNDUP(fp);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  printf(&quot;backtrace:\n&quot;);</span></span><br><span class="line"><span class="addition">+  while (fp &lt; top) &#123;</span></span><br><span class="line"><span class="addition">+    retaddr = *(uint64 *)(fp - 8);</span></span><br><span class="line"><span class="addition">+    printf(&quot;%p\n&quot;, retaddr);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    fp = *(uint64 *)(fp - 16);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><h3 id="关键实现-1"><a href="#关键实现-1" class="headerlink" title="关键实现"></a>关键实现</h3><p>1、<code>kernel/proc.h</code>：在 <code>struct proc</code> 添加必要的结构体成员（passed ticks、ticks 阈值、handler 地址、trapframe 备份）<br><strong>优化：这些结构体可以通过单独放到一个 <code>struct alarm</code> 的结构体里，这样就可以达到在不添加 alarm 前缀的情况下区分不同成员的命名。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// traps alarm</span></span><br><span class="line">    <span class="type">int</span> alarm_passed;</span><br><span class="line">    <span class="type">int</span> alarm_threshold;</span><br><span class="line">    uint64 alarm_handler;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">alarm_prev_trapframe</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 2、解析用户态调用的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> period;</span><br><span class="line">    uint64 handler;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    argint(<span class="number">0</span>, &amp;period);</span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;handler);</span><br><span class="line"></span><br><span class="line">    p-&gt;alarm_threshold = period;</span><br><span class="line">    p-&gt;alarm_handler = handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、每次时钟中断都会调用 usertrap。因此，我们在 usertrap 里实现 alarm feature。每次发生时钟中断时候，递增 alarm_passed，当 alarm_passed 等于设置的阈值时，此时需要返回用户态，执行用户态的 handler。<br><strong>注：是返回用户态执行 handler，不是直接在内核态执行 handler。</strong></p>
<p>让流程返回用户态，只需要将 epc 设置为 handler 的地址即可，当返回用户态时候就会从 epc 指向的地方开始执行。在返回之前，我们需要保存现场，将 trapframe 结构体保存到 alarm_prev_trapframe 里，赋值语法是 C 语言的结构体赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span> (which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    p-&gt;alarm_passed++;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;alarm_passed == p-&gt;alarm_threshold) &#123;</span><br><span class="line">      *(p-&gt;alarm_prev_trapframe) = *(p-&gt;trapframe);</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 4、中断返回，返回需要先恢复现场，恢复到发生中断前。通过将 alarm_prev_trapframe 中保存的现场恢复到 trapframe 即可。重置 alarm_passed。 题目要求，返回值是 <code>a0</code> 寄存的值，不能直接写 <code>return 0</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    *(p-&gt;trapframe) = *(p-&gt;alarm_prev_trapframe);</span><br><span class="line">    p-&gt;alarm_passed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Show-me-the-code-1"><a href="#Show-me-the-code-1" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/Makefile b/Makefile</span></span><br><span class="line"><span class="comment">index 46997f8..b5eaf29 100644</span></span><br><span class="line"><span class="comment">--- a/Makefile</span></span><br><span class="line"><span class="comment">+++ b/Makefile</span></span><br><span class="line"><span class="meta">@@ -188,6 +188,7 @@</span> UPROGS=\</span><br><span class="line"> 	$U/_grind\</span><br><span class="line"> 	$U/_wc\</span><br><span class="line"> 	$U/_zombie\</span><br><span class="line"><span class="addition">+	$U/_alarmtest\</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/kernel/proc.c b/kernel/proc.c</span></span><br><span class="line"><span class="comment">index 4315d58..ae8d6ed 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.c</span></span><br><span class="line"><span class="meta">@@ -133,6 +133,13 @@</span> allocproc(void)</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  //  Allocate a trapframe page for alarm</span></span><br><span class="line"><span class="addition">+  if ((p-&gt;alarm_prev_trapframe = (struct trapframe *)kalloc()) == 0) &#123;</span></span><br><span class="line"><span class="addition">+    freeproc(p);</span></span><br><span class="line"><span class="addition">+    release(&amp;p-&gt;lock);</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   // An empty user page table.</span><br><span class="line">   p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">   if (p-&gt;pagetable == 0) &#123;</span><br><span class="line"><span class="meta">@@ -147,6 +154,10 @@</span> allocproc(void)</span><br><span class="line">   p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">   p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  p-&gt;alarm_passed = 0;</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_threshold = 0;</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_handler = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   return p;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -159,6 +170,9 @@</span> freeproc(struct proc *p)</span><br><span class="line">   if (p-&gt;trapframe)</span><br><span class="line">     kfree((void *)p-&gt;trapframe);</span><br><span class="line">   p-&gt;trapframe = 0;</span><br><span class="line"><span class="addition">+  if (p-&gt;alarm_prev_trapframe)</span></span><br><span class="line"><span class="addition">+    kfree((void *)p-&gt;alarm_prev_trapframe);</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_prev_trapframe = 0;</span></span><br><span class="line">   if (p-&gt;pagetable)</span><br><span class="line">     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">   p-&gt;pagetable = 0;</span><br><span class="line"><span class="meta">@@ -170,6 +184,10 @@</span> freeproc(struct proc *p)</span><br><span class="line">   p-&gt;killed = 0;</span><br><span class="line">   p-&gt;xstate = 0;</span><br><span class="line">   p-&gt;state = UNUSED;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_passed = 0;</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_threshold = 0;</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_handler = 0;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // Create a user page table for a given process, with no user memory,</span><br><span class="line"><span class="comment">diff --git a/kernel/proc.h b/kernel/proc.h</span></span><br><span class="line"><span class="comment">index a74496c..fe3d174 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/proc.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/proc.h</span></span><br><span class="line"><span class="meta">@@ -104,4 +104,10 @@</span> struct proc &#123;</span><br><span class="line">   struct file *ofile[NOFILE];  // Open files</span><br><span class="line">   struct inode *cwd;           // Current directory</span><br><span class="line">   char name[16];               // Process name (debugging)</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // traps alarm</span></span><br><span class="line"><span class="addition">+  int alarm_passed;</span></span><br><span class="line"><span class="addition">+  int alarm_threshold;</span></span><br><span class="line"><span class="addition">+  uint64 alarm_handler;</span></span><br><span class="line"><span class="addition">+  struct trapframe *alarm_prev_trapframe;</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">diff --git a/kernel/syscall.c b/kernel/syscall.c</span></span><br><span class="line"><span class="comment">index b1f6d3d..4e19877 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/syscall.c</span></span><br><span class="line"><span class="meta">@@ -102,6 +102,8 @@</span> extern uint64 sys_unlink(void);</span><br><span class="line"> extern uint64 sys_link(void);</span><br><span class="line"> extern uint64 sys_mkdir(void);</span><br><span class="line"> extern uint64 sys_close(void);</span><br><span class="line"><span class="addition">+extern uint64 sys_sigalarm(void);</span></span><br><span class="line"><span class="addition">+extern uint64 sys_sigreturn(void);</span></span><br><span class="line"> </span><br><span class="line"> // An array mapping syscall numbers from syscall.h</span><br><span class="line"> // to the function that handles the system call.</span><br><span class="line"><span class="meta">@@ -113,6 +115,7 @@</span> static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line">     [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,</span><br><span class="line">     [SYS_write] sys_write, [SYS_mknod] sys_mknod,   [SYS_unlink] sys_unlink,</span><br><span class="line">     [SYS_link] sys_link,   [SYS_mkdir] sys_mkdir,   [SYS_close] sys_close,</span><br><span class="line"><span class="addition">+    [SYS_sigalarm] sys_sigalarm, [SYS_sigreturn] sys_sigreturn,</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> void</span><br><span class="line"><span class="comment">diff --git a/kernel/syscall.h b/kernel/syscall.h</span></span><br><span class="line"><span class="comment">index 1e1f4ba..2133a24 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/syscall.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/syscall.h</span></span><br><span class="line"><span class="meta">@@ -20,3 +20,5 @@</span></span><br><span class="line"> #define SYS_link 19</span><br><span class="line"> #define SYS_mkdir 20</span><br><span class="line"> #define SYS_close 21</span><br><span class="line"><span class="addition">+#define SYS_sigalarm 22</span></span><br><span class="line"><span class="addition">+#define SYS_sigreturn 23</span></span><br><span class="line">\ No newline at end of file</span><br><span class="line"><span class="comment">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">index 0cd201d..0c61942 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/sysproc.c</span></span><br><span class="line"><span class="meta">@@ -93,3 +93,30 @@</span> sys_uptime(void)</span><br><span class="line">   release(&amp;tickslock);</span><br><span class="line">   return xticks;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+uint64</span></span><br><span class="line"><span class="addition">+sys_sigalarm(void)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  int period;</span></span><br><span class="line"><span class="addition">+  uint64 handler;</span></span><br><span class="line"><span class="addition">+  struct proc *p = myproc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  argint(0, &amp;period);</span></span><br><span class="line"><span class="addition">+  argaddr(1, &amp;handler);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_threshold = period;</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_handler = handler;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+uint64</span></span><br><span class="line"><span class="addition">+sys_sigreturn(void)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  struct proc *p = myproc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  *(p-&gt;trapframe) = *(p-&gt;alarm_prev_trapframe);</span></span><br><span class="line"><span class="addition">+  p-&gt;alarm_passed = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return p-&gt;trapframe-&gt;a0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="comment">diff --git a/kernel/trap.c b/kernel/trap.c</span></span><br><span class="line"><span class="comment">index 0dcd358..58de139 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/trap.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/trap.c</span></span><br><span class="line"><span class="meta">@@ -79,8 +79,19 @@</span> usertrap(void)</span><br><span class="line">     exit(-1);</span><br><span class="line"> </span><br><span class="line">   // give up the CPU if this is a timer interrupt.</span><br><span class="line"><span class="deletion">-  if (which_dev == 2)</span></span><br><span class="line"><span class="addition">+  if (which_dev == 2) &#123;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    // stop generating periodic alarm calls if threshold is 0</span></span><br><span class="line"><span class="addition">+    if (p-&gt;alarm_threshold != 0) &#123;</span></span><br><span class="line"><span class="addition">+      p-&gt;alarm_passed++;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+      if (p-&gt;alarm_passed == p-&gt;alarm_threshold) &#123;</span></span><br><span class="line"><span class="addition">+        *(p-&gt;alarm_prev_trapframe) = *(p-&gt;trapframe);</span></span><br><span class="line"><span class="addition">+        p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">     yield();</span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"> </span><br><span class="line">   usertrapret();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">diff --git a/user/alarmtest.c b/user/alarmtest.c</span></span><br><span class="line"><span class="comment">index 2337221..9abd157 100644</span></span><br><span class="line"><span class="comment">--- a/user/alarmtest.c</span></span><br><span class="line"><span class="comment">+++ b/user/alarmtest.c</span></span><br><span class="line"><span class="meta">@@ -106,6 +106,7 @@</span> test1()</span><br><span class="line">     // occurred; another is that that registers may not be</span><br><span class="line">     // restored correctly, causing i or j or the address ofj</span><br><span class="line">     // to get an incorrect value.</span><br><span class="line"><span class="addition">+    printf(&quot;\n test1: i: %d, j:%d\n&quot;, i, j);</span></span><br><span class="line">     printf(&quot;\ntest1 failed: foo() executed fewer times than it was called\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line"><span class="comment">diff --git a/user/user.h b/user/user.h</span></span><br><span class="line"><span class="comment">index 5837a96..fdcc993 100644</span></span><br><span class="line"><span class="comment">--- a/user/user.h</span></span><br><span class="line"><span class="comment">+++ b/user/user.h</span></span><br><span class="line"><span class="meta">@@ -22,6 +22,8 @@</span> int getpid(void);</span><br><span class="line"> char *sbrk(int);</span><br><span class="line"> int sleep(int);</span><br><span class="line"> int uptime(void);</span><br><span class="line"><span class="addition">+int sigalarm(int ticks, void (*handler)());</span></span><br><span class="line"><span class="addition">+int sigreturn(void);</span></span><br><span class="line"> </span><br><span class="line"> // ulib.c</span><br><span class="line"> int stat(const char *, struct stat *);</span><br><span class="line"><span class="comment">diff --git a/user/usys.pl b/user/usys.pl</span></span><br><span class="line"><span class="comment">index 01e426e..3c258dc 100755</span></span><br><span class="line"><span class="comment">--- a/user/usys.pl</span></span><br><span class="line"><span class="comment">+++ b/user/usys.pl</span></span><br><span class="line"><span class="meta">@@ -36,3 +36,5 @@</span> sub entry &#123;</span><br><span class="line"> entry(&quot;sbrk&quot;);</span><br><span class="line"> entry(&quot;sleep&quot;);</span><br><span class="line"> entry(&quot;uptime&quot;);</span><br><span class="line"><span class="addition">+entry(&quot;sigalarm&quot;);</span></span><br><span class="line"><span class="addition">+entry(&quot;sigreturn&quot;);</span></span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>





<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>最后，执行 <code>make grade</code> 查看结果，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">== Test answers-traps.txt ==</span><br><span class="line">answers-traps.txt: OK</span><br><span class="line">== Test backtrace test == backtrace test: OK (3.9s)</span><br><span class="line">== Test running alarmtest == (5.6s)</span><br><span class="line">== Test   alarmtest: test0 ==</span><br><span class="line">alarmtest: test0: OK</span><br><span class="line">== Test   alarmtest: test1 ==</span><br><span class="line">alarmtest: test1: OK</span><br><span class="line">== Test   alarmtest: test2 ==</span><br><span class="line">alarmtest: test2: OK</span><br><span class="line">== Test   alarmtest: test3 ==</span><br><span class="line">alarmtest: test3: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">usertests: OK (149.0s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 95/95</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
  </entry>
  <entry>
    <title>xv6 Lab5: COW</title>
    <url>/xv6-lab5-cow.md.html</url>
    <content><![CDATA[<p>Lab5 的任务是在 xv6 内核中实现 COW fork。叫做 lazy fork 也行。</p>
<h2 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h2><h2 id="关键实现"><a href="#关键实现" class="headerlink" title="关键实现"></a>关键实现</h2><h3 id="struct-kmem"><a href="#struct-kmem" class="headerlink" title="struct kmem"></a>struct kmem</h3><p>在 struct kmem 结构体中引入引用计数成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">    <span class="type">int</span> ref_count[PHYSTOP / PGSIZE];</span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<p>并引入几个快捷操作函数，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_kmemref</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    <span class="type">int</span> refcnt = kmem.ref_count[(uint64)pa / PGSIZE];</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> refcnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inc_kmemref</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    kmem.ref_count[(uint64)pa / PGSIZE]++;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dec_kmemref</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    kmem.ref_count[(uint64)pa / PGSIZE]--;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="uvmcopy"><a href="#uvmcopy" class="headerlink" title="uvmcopy"></a>uvmcopy</h3><p>uvmcopy 是用来拷贝父进程的地址空间的，将其修改为 COW 形式，将原有的 kalloc 行为延迟的运行时。实现方式为，</p>
<ul>
<li>移除父子进程地址空间的写权限</li>
<li>增加 COW 标记</li>
<li>增加引用计数（kfree 需要）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *pte = (*pte &amp; (~PTE_W)) | PTE_COW;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="keyword">if</span> (mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        inc_kmemref((<span class="type">void</span> *)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h3><p><code>sscause</code> 寄存器值位 15 代表 page write fault，此时触发 cowhandler 复制地址空间，处理完成移除页面 COW 位，并将页面标记为可写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">		uint64 va0 = r_stval();</span><br><span class="line">		<span class="keyword">if</span> (cowhandler(p-&gt;pagetable, va0) != <span class="number">0</span>) &#123;</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cowhandler</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">	<span class="type">pte_t</span> *pte;</span><br><span class="line">	uint64 *mem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pte = walk(pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(*pte &amp; PTE_COW) || !(*pte &amp; PTE_U) || !(*pte &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uint64 pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> refcnt = get_kmemref((<span class="type">void</span> *)pa);</span><br><span class="line">	<span class="keyword">if</span> (refcnt == <span class="number">1</span>) &#123;</span><br><span class="line">		*pte = (*pte &amp; (~PTE_COW)) | PTE_W; <span class="comment">// mark it writeable &amp; remove COW bit</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		memmove((<span class="type">void</span> *)mem, (<span class="type">void</span> *)pa, PGSIZE);</span><br><span class="line">		kfree((<span class="type">void</span> *)pa); <span class="comment">// remove old ref</span></span><br><span class="line"></span><br><span class="line">		uint flags = PTE_FLAGS(*pte);</span><br><span class="line">		*pte = (PA2PTE(mem) | (flags &amp; ~PTE_COW)) | PTE_W; <span class="comment">// make it writeable &amp; remove COW bit</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h3><p>copyout 过程中也属于一个 case。需要进行 cow 处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">    uint64 n, va0, pa0;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 *mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        va0 = PGROUNDDOWN(dstva);</span><br><span class="line">        pa0 = walkaddr(pagetable, va0);</span><br><span class="line">        <span class="keyword">if</span> (pa0 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (va0 &gt;= MAXVA || va0 &lt; PGSIZE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(pagetable, va0, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((*pte &amp; PTE_V) &amp;&amp; (*pte &amp; PTE_COW) &amp;&amp; (*pte &amp; PTE_U)) &#123;</span><br><span class="line">            <span class="type">int</span> refcnt = get_kmemref((<span class="type">void</span> *)pa0);</span><br><span class="line">            <span class="keyword">if</span> (refcnt == <span class="number">1</span>) &#123;</span><br><span class="line">                *pte = (*pte &amp; (~PTE_COW)) | PTE_W;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                memmove((<span class="type">void</span> *)mem, (<span class="type">void</span> *)pa0, PGSIZE);</span><br><span class="line">                uint flags = PTE_FLAGS(*pte);</span><br><span class="line">                *pte = (PA2PTE(mem) | (flags &amp; ~PTE_COW)) | PTE_W; <span class="comment">// writeable &amp; remove COW bit</span></span><br><span class="line"></span><br><span class="line">                pa0 = (uint64)mem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = PGSIZE - (dstva - va0);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len)</span><br><span class="line">            n = len;</span><br><span class="line">        memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">        len -= n;</span><br><span class="line">        src += n;</span><br><span class="line">        dstva = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/defs.h b/kernel/defs.h</span></span><br><span class="line"><span class="comment">index a3c962b..8c4ebb8 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/defs.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/defs.h</span></span><br><span class="line"><span class="meta">@@ -63,6 +63,9 @@</span> void            ramdiskrw(struct buf*);</span><br><span class="line"> void*           kalloc(void);</span><br><span class="line"> void            kfree(void *);</span><br><span class="line"> void            kinit(void);</span><br><span class="line"><span class="addition">+void            inc_kmemref(void*);</span></span><br><span class="line"><span class="addition">+void            dec_kmemref(void*);</span></span><br><span class="line"><span class="addition">+char            get_kmemref(void*);</span></span><br><span class="line"> </span><br><span class="line"> // log.c</span><br><span class="line"> void            initlog(int, struct superblock*);</span><br><span class="line"><span class="meta">@@ -147,6 +150,7 @@</span> void            trapinit(void);</span><br><span class="line"> void            trapinithart(void);</span><br><span class="line"> extern struct spinlock tickslock;</span><br><span class="line"> void            usertrapret(void);</span><br><span class="line"><span class="addition">+int             cowhandler(pagetable_t, uint64);</span></span><br><span class="line"> </span><br><span class="line"> // uart.c</span><br><span class="line"> void            uartinit(void);</span><br><span class="line"><span class="comment">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span></span><br><span class="line"><span class="comment">index 0699e7e..4baa07c 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/kalloc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/kalloc.c</span></span><br><span class="line"><span class="meta">@@ -21,6 +21,7 @@</span> struct run &#123;</span><br><span class="line"> struct &#123;</span><br><span class="line">   struct spinlock lock;</span><br><span class="line">   struct run *freelist;</span><br><span class="line"><span class="addition">+  char ref_count[PHYSTOP/PGSIZE];</span></span><br><span class="line"> &#125; kmem;</span><br><span class="line"> </span><br><span class="line"> void</span><br><span class="line"><span class="meta">@@ -34,9 +35,15 @@</span> void</span><br><span class="line"> freerange(void *pa_start, void *pa_end)</span><br><span class="line"> &#123;</span><br><span class="line">   char *p;</span><br><span class="line"><span class="addition">+  int i;</span></span><br><span class="line">   p = (char*)PGROUNDUP((uint64)pa_start);</span><br><span class="line"><span class="deletion">-  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)</span></span><br><span class="line"><span class="addition">+  for(i=0; i&lt;(uint64)p/PGSIZE; i++) &#123;</span></span><br><span class="line"><span class="addition">+    kmem.ref_count[i] = 0;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE) &#123;</span></span><br><span class="line"><span class="addition">+    kmem.ref_count[(uint64)p/PGSIZE] = 1;</span></span><br><span class="line">     kfree(p);</span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // Free the page of physical memory pointed at by pa,</span><br><span class="line"><span class="meta">@@ -51,6 +58,11 @@</span> kfree(void *pa)</span><br><span class="line">   if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">     panic(&quot;kfree&quot;);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+	if (get_kmemref(pa) &gt; 1) &#123;</span></span><br><span class="line"><span class="addition">+		dec_kmemref(pa);</span></span><br><span class="line"><span class="addition">+		return;</span></span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"><span class="addition">+  </span></span><br><span class="line">   // Fill with junk to catch dangling refs.</span><br><span class="line">   memset(pa, 1, PGSIZE);</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -72,11 +84,40 @@</span> kalloc(void)</span><br><span class="line"> </span><br><span class="line">   acquire(&amp;kmem.lock);</span><br><span class="line">   r = kmem.freelist;</span><br><span class="line"><span class="deletion">-  if(r)</span></span><br><span class="line"><span class="addition">+  if(r) &#123;</span></span><br><span class="line">     kmem.freelist = r-&gt;next;</span><br><span class="line"><span class="addition">+    kmem.ref_count[(uint64)r / PGSIZE] = 1;</span></span><br><span class="line"><span class="addition">+  &#125;   </span></span><br><span class="line">   release(&amp;kmem.lock);</span><br><span class="line"> </span><br><span class="line">   if(r)</span><br><span class="line">     memset((char*)r, 5, PGSIZE); // fill with junk</span><br><span class="line">   return (void*)r;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+char</span></span><br><span class="line"><span class="addition">+get_kmemref(void *pa)&#123;</span></span><br><span class="line"><span class="addition">+  acquire(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  char refcnt = kmem.ref_count[(uint64)pa/PGSIZE];</span></span><br><span class="line"><span class="addition">+  release(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  return refcnt;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void</span></span><br><span class="line"><span class="addition">+inc_kmemref(void *pa)&#123;</span></span><br><span class="line"><span class="addition">+  acquire(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  kmem.ref_count[(uint64)pa/PGSIZE]++;</span></span><br><span class="line"><span class="addition">+  release(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void</span></span><br><span class="line"><span class="addition">+dec_kmemref(void *pa)&#123;</span></span><br><span class="line"><span class="addition">+  acquire(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  kmem.ref_count[(uint64)pa/PGSIZE]--;</span></span><br><span class="line"><span class="addition">+  release(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="comment">diff --git a/kernel/riscv.h b/kernel/riscv.h</span></span><br><span class="line"><span class="comment">index 20a01db..7eb2bd4 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/riscv.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/riscv.h</span></span><br><span class="line"><span class="meta">@@ -343,6 +343,7 @@</span> typedef uint64 *pagetable_t; // 512 PTEs</span><br><span class="line"> #define PTE_W (1L &lt;&lt; 2)</span><br><span class="line"> #define PTE_X (1L &lt;&lt; 3)</span><br><span class="line"> #define PTE_U (1L &lt;&lt; 4) // user can access</span><br><span class="line"><span class="addition">+#define PTE_COW (1L &lt;&lt; 8)  // cow page</span></span><br><span class="line"> </span><br><span class="line"> // shift a physical address to the right place for a PTE.</span><br><span class="line"> #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span><br><span class="line"><span class="comment">diff --git a/kernel/trap.c b/kernel/trap.c</span></span><br><span class="line"><span class="comment">index 512c850..e6be7fd 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/trap.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/trap.c</span></span><br><span class="line"><span class="meta">@@ -65,6 +65,15 @@</span> usertrap(void)</span><br><span class="line">     intr_on();</span><br><span class="line"> </span><br><span class="line">     syscall();</span><br><span class="line"><span class="addition">+  &#125; else if(r_scause() == 15) &#123; // 写页面错</span></span><br><span class="line"><span class="addition">+    uint64 va0 = r_stval();</span></span><br><span class="line"><span class="addition">+    if(va0 &gt; p-&gt;sz) &#123;</span></span><br><span class="line"><span class="addition">+      p-&gt;killed = 1;</span></span><br><span class="line"><span class="addition">+    &#125; else if(cowhandler(p-&gt;pagetable,va0) !=0 ) &#123;</span></span><br><span class="line"><span class="addition">+      p-&gt;killed = 1;</span></span><br><span class="line"><span class="addition">+    &#125; else if(va0 &lt; PGSIZE) &#123;</span></span><br><span class="line"><span class="addition">+      p-&gt;killed = 1;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">   &#125; else if((which_dev = devintr()) != 0)&#123;</span><br><span class="line">     // ok</span><br><span class="line">   &#125; else &#123;</span><br><span class="line"><span class="meta">@@ -219,3 +228,37 @@</span> devintr()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+int</span></span><br><span class="line"><span class="addition">+cowhandler(pagetable_t pagetable, uint64 va)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    char *mem;</span></span><br><span class="line"><span class="addition">+    if (va &gt;= MAXVA)</span></span><br><span class="line"><span class="addition">+      return -1;</span></span><br><span class="line"><span class="addition">+    pte_t *pte = walk(pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+    if (pte == 0)</span></span><br><span class="line"><span class="addition">+      return -1;</span></span><br><span class="line"><span class="addition">+    // check the PTE</span></span><br><span class="line"><span class="addition">+    if ((*pte &amp; PTE_COW) == 0 || (*pte &amp; PTE_U) == 0 || (*pte &amp; PTE_V) == 0) &#123;</span></span><br><span class="line"><span class="addition">+      return -1;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    uint64 pa = PTE2PA(*pte);</span></span><br><span class="line"><span class="addition">+    char refcnt = get_kmemref((void *)pa);</span></span><br><span class="line"><span class="addition">+    if(refcnt == 1) &#123;</span></span><br><span class="line"><span class="addition">+       *pte = (*pte &amp; (~PTE_COW)) | PTE_W;</span></span><br><span class="line"><span class="addition">+       return 0;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    if(refcnt &gt; 1) &#123;</span></span><br><span class="line"><span class="addition">+      if ((mem = kalloc()) == 0) &#123;</span></span><br><span class="line"><span class="addition">+        return -1;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+      // copy old data to new mem</span></span><br><span class="line"><span class="addition">+      memmove((char*)mem, (char*)pa, PGSIZE);</span></span><br><span class="line"><span class="addition">+      kfree((void*)pa);</span></span><br><span class="line"><span class="addition">+      uint flags = PTE_FLAGS(*pte);</span></span><br><span class="line"><span class="addition">+      *pte = (PA2PTE(mem) | flags | PTE_W);</span></span><br><span class="line"><span class="addition">+      *pte &amp;= ~PTE_COW;</span></span><br><span class="line"><span class="addition">+      return 0;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    return -1;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="comment">diff --git a/kernel/vm.c b/kernel/vm.c</span></span><br><span class="line"><span class="comment">index 5c31e87..78551b0 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/vm.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/vm.c</span></span><br><span class="line"><span class="meta">@@ -5,7 +5,8 @@</span></span><br><span class="line"> #include &quot;riscv.h&quot;</span><br><span class="line"> #include &quot;defs.h&quot;</span><br><span class="line"> #include &quot;fs.h&quot;</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+#include &quot;spinlock.h&quot;</span></span><br><span class="line"><span class="addition">+#include &quot;proc.h&quot;</span></span><br><span class="line"> /*</span><br><span class="line">  * the kernel&#x27;s page table.</span><br><span class="line">  */</span><br><span class="line"><span class="meta">@@ -160,8 +161,8 @@</span> mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</span><br><span class="line">   for(;;)&#123;</span><br><span class="line">     if((pte = walk(pagetable, a, 1)) == 0)</span><br><span class="line">       return -1;</span><br><span class="line"><span class="deletion">-    if(*pte &amp; PTE_V)</span></span><br><span class="line"><span class="deletion">-      panic(&quot;mappages: remap&quot;);</span></span><br><span class="line"><span class="addition">+//    if(*pte &amp; PTE_V)</span></span><br><span class="line"><span class="addition">+//      panic(&quot;mappages: remap&quot;);</span></span><br><span class="line">     *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">     if(a == last)</span><br><span class="line">       break;</span><br><span class="line"><span class="meta">@@ -315,22 +316,22 @@</span> uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span><br><span class="line">   pte_t *pte;</span><br><span class="line">   uint64 pa, i;</span><br><span class="line">   uint flags;</span><br><span class="line"><span class="deletion">-  char *mem;</span></span><br><span class="line"> </span><br><span class="line">   for(i = 0; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">     if((pte = walk(old, i, 0)) == 0)</span><br><span class="line">       panic(&quot;uvmcopy: pte should exist&quot;);</span><br><span class="line">     if((*pte &amp; PTE_V) == 0)</span><br><span class="line">       panic(&quot;uvmcopy: page not present&quot;);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    if(*pte &amp; PTE_W) &#123;</span></span><br><span class="line"><span class="addition">+      *pte = (*pte &amp; (~PTE_W)) | PTE_COW;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">     pa = PTE2PA(*pte);</span><br><span class="line">     flags = PTE_FLAGS(*pte);</span><br><span class="line"><span class="deletion">-    if((mem = kalloc()) == 0)</span></span><br><span class="line"><span class="deletion">-      goto err;</span></span><br><span class="line"><span class="deletion">-    memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line"><span class="deletion">-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span></span><br><span class="line"><span class="deletion">-      kfree(mem);</span></span><br><span class="line"><span class="addition">+    if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0)&#123;</span></span><br><span class="line">       goto err;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    inc_kmemref((void *)pa);</span></span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -360,23 +361,48 @@</span> copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</span><br><span class="line"> &#123;</span><br><span class="line">   uint64 n, va0, pa0;</span><br><span class="line">   pte_t *pte;</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+ </span></span><br><span class="line">   while(len &gt; 0)&#123;</span><br><span class="line">     va0 = PGROUNDDOWN(dstva);</span><br><span class="line"><span class="addition">+    pa0 = walkaddr(pagetable, va0); </span></span><br><span class="line"><span class="addition">+    if(pa0 == 0) </span></span><br><span class="line"><span class="addition">+      return -1;</span></span><br><span class="line"><span class="addition">+    struct proc *p = myproc();</span></span><br><span class="line">     if(va0 &gt;= MAXVA)</span><br><span class="line">       return -1;</span><br><span class="line"><span class="deletion">-    pte = walk(pagetable, va0, 0);</span></span><br><span class="line"><span class="deletion">-    if(pte == 0 || (*pte &amp; PTE_V) == 0 || (*pte &amp; PTE_U) == 0 ||</span></span><br><span class="line"><span class="deletion">-       (*pte &amp; PTE_W) == 0)</span></span><br><span class="line"><span class="addition">+    if(va0 &lt; PGSIZE)</span></span><br><span class="line"><span class="addition">+      return -1;</span></span><br><span class="line"><span class="addition">+    if((pte = walk(pagetable, va0, 0))==0) &#123;</span></span><br><span class="line"><span class="addition">+      p-&gt;killed = 1;     </span></span><br><span class="line">       return -1;</span><br><span class="line"><span class="deletion">-    pa0 = PTE2PA(*pte);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    if ((va0 &lt; p-&gt;sz) &amp;&amp; (*pte &amp; PTE_V) &amp;&amp;</span></span><br><span class="line"><span class="addition">+            (*pte &amp; PTE_COW)&amp;&amp;(*pte &amp; PTE_U)) &#123;</span></span><br><span class="line"><span class="addition">+      char refcnt = get_kmemref((void *)pa0);</span></span><br><span class="line"><span class="addition">+      if(refcnt == 1) &#123;</span></span><br><span class="line"><span class="addition">+         *pte = (*pte &amp;(~PTE_COW)) | PTE_W;</span></span><br><span class="line"><span class="addition">+      &#125;else if(refcnt &gt; 1)&#123;</span></span><br><span class="line"><span class="addition">+        char *mem;</span></span><br><span class="line"><span class="addition">+        dec_kmemref((void *)pa0);</span></span><br><span class="line"><span class="addition">+        if ((mem = kalloc()) == 0) &#123;</span></span><br><span class="line"><span class="addition">+          p-&gt;killed = 1;        </span></span><br><span class="line"><span class="addition">+          return -1;</span></span><br><span class="line"><span class="addition">+        &#125; </span></span><br><span class="line"><span class="addition">+        memmove(mem, (char*)pa0, PGSIZE);</span></span><br><span class="line"><span class="addition">+        uint flags = PTE_FLAGS(*pte);</span></span><br><span class="line"><span class="addition">+        *pte = (PA2PTE(mem) | flags | PTE_W);</span></span><br><span class="line"><span class="addition">+        *pte &amp;= ~PTE_COW;</span></span><br><span class="line"><span class="addition">+        pa0 = (uint64)mem;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">     n = PGSIZE - (dstva - va0);</span><br><span class="line">     if(n &gt; len)</span><br><span class="line">       n = len;</span><br><span class="line">     memmove((void *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"> </span><br><span class="line">     len -= n;</span><br><span class="line"><span class="deletion">-    src += n;</span></span><br><span class="line"><span class="addition">+    src += n; </span></span><br><span class="line">     dstva = va0 + PGSIZE;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br></pre></td></tr></table></figure>


<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">(12.3s)</span><br><span class="line">== Test   simple ==</span><br><span class="line">  simple: OK</span><br><span class="line">== Test   three ==</span><br><span class="line">  three: OK</span><br><span class="line">== Test   file ==</span><br><span class="line">  file: OK</span><br><span class="line">== Test usertests ==</span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(118.3s)</span><br><span class="line">== Test   usertests: copyin ==</span><br><span class="line">  usertests: copyin: OK</span><br><span class="line">== Test   usertests: copyout ==</span><br><span class="line">  usertests: copyout: OK</span><br><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: OK</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 110/110</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>xv6</category>
      </categories>
  </entry>
  <entry>
    <title>xv6 Lab6: Multithreading</title>
    <url>/xv6-lab6-multithreading.html</url>
    <content><![CDATA[<p>这个实验是熟悉多线程。需要实现在一个用户态的线程切换，使用多个线程来加速程序，并实现一个屏障。</p>
<h2 id="uthread"><a href="#uthread" class="headerlink" title="uthread"></a>uthread</h2><p>打开 user&#x2F;uthread.c 文件，观察 uthread 的数据结构以及部分函数实现能帮我们快速理清思路。</p>
<h3 id="关键实现"><a href="#关键实现" class="headerlink" title="关键实现"></a>关键实现</h3><h4 id="struct-context-thread-switch"><a href="#struct-context-thread-switch" class="headerlink" title="struct context &#x2F; thread_switch"></a>struct context &#x2F; thread_switch</h4><p>一个是上下文，一个是线程切换对应的底层汇编。如介绍所言，从内核部分复制过来就行了。</p>
<h4 id="thread-schedule"><a href="#thread-schedule" class="headerlink" title="thread_schedule"></a>thread_schedule</h4><p>线程上下文切换，传入上下文 ctx  即可，其他状态的切换代码已经有了。</p>
<h4 id="thread-create"><a href="#thread-create" class="headerlink" title="thread_create"></a>thread_create</h4><p>线程创建，创建时，只需要指定 ra 和 sp 两个寄存器即可，ra 指向需要执行的 func，sp 指向栈低(高地址)，栈是从高往低增长的，故需指向高地址的栈底。</p>
<h3 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/user/uthread.c b/user/uthread.c</span></span><br><span class="line"><span class="comment">index f9795ab..0ed406a 100644</span></span><br><span class="line"><span class="comment">--- a/user/uthread.c</span></span><br><span class="line"><span class="comment">+++ b/user/uthread.c</span></span><br><span class="line"><span class="meta">@@ -10,9 +10,31 @@</span></span><br><span class="line"> #define STACK_SIZE 8192</span><br><span class="line"> #define MAX_THREAD 4</span><br><span class="line"> </span><br><span class="line"><span class="addition">+// Saved registers for uthread context switches.</span></span><br><span class="line"><span class="addition">+// Copy from kernel/proc.h</span></span><br><span class="line"><span class="addition">+struct context &#123;</span></span><br><span class="line"><span class="addition">+  uint64 ra; /* return address */</span></span><br><span class="line"><span class="addition">+  uint64 sp; /* stack pointer */</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // callee-saved</span></span><br><span class="line"><span class="addition">+  uint64 s0;</span></span><br><span class="line"><span class="addition">+  uint64 s1;</span></span><br><span class="line"><span class="addition">+  uint64 s2;</span></span><br><span class="line"><span class="addition">+  uint64 s3;</span></span><br><span class="line"><span class="addition">+  uint64 s4;</span></span><br><span class="line"><span class="addition">+  uint64 s5;</span></span><br><span class="line"><span class="addition">+  uint64 s6;</span></span><br><span class="line"><span class="addition">+  uint64 s7;</span></span><br><span class="line"><span class="addition">+  uint64 s8;</span></span><br><span class="line"><span class="addition">+  uint64 s9;</span></span><br><span class="line"><span class="addition">+  uint64 s10;</span></span><br><span class="line"><span class="addition">+  uint64 s11;</span></span><br><span class="line"><span class="addition">+&#125;;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> struct thread &#123;</span><br><span class="line">   char stack[STACK_SIZE]; /* the thread&#x27;s stack */</span><br><span class="line">   int state;              /* FREE, RUNNING, RUNNABLE */</span><br><span class="line"><span class="addition">+  struct context ctx;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> struct thread all_thread[MAX_THREAD];</span><br><span class="line"> struct thread *current_thread;</span><br><span class="line"><span class="meta">@@ -55,10 +77,7 @@</span> thread_schedule(void)</span><br><span class="line">     next_thread-&gt;state = RUNNING;</span><br><span class="line">     t = current_thread;</span><br><span class="line">     current_thread = next_thread;</span><br><span class="line"><span class="deletion">-    /* YOUR CODE HERE</span></span><br><span class="line"><span class="deletion">-     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="deletion">-     * thread_switch(??, ??);</span></span><br><span class="line"><span class="deletion">-     */</span></span><br><span class="line"><span class="addition">+    thread_switch((uint64)&amp;t-&gt;ctx, (uint64)&amp;current_thread-&gt;ctx);</span></span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">     next_thread = 0;</span><br><span class="line"><span class="meta">@@ -74,7 +93,8 @@</span> thread_create(void (*func)())</span><br><span class="line">       break;</span><br><span class="line">   &#125;</span><br><span class="line">   t-&gt;state = RUNNABLE;</span><br><span class="line"><span class="deletion">-  // YOUR CODE HERE</span></span><br><span class="line"><span class="addition">+  t-&gt;ctx.ra = (uint64)func;</span></span><br><span class="line"><span class="addition">+  t-&gt;ctx.sp = (uint64)&amp;t-&gt;stack[STACK_SIZE - 1];</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void</span><br><span class="line"><span class="comment">diff --git a/user/uthread_switch.S b/user/uthread_switch.S</span></span><br><span class="line"><span class="comment">index 5defb12..8deb723 100644</span></span><br><span class="line"><span class="comment">--- a/user/uthread_switch.S</span></span><br><span class="line"><span class="comment">+++ b/user/uthread_switch.S</span></span><br><span class="line"><span class="meta">@@ -7,5 +7,35 @@</span></span><br><span class="line"> </span><br><span class="line"> 	.globl thread_switch</span><br><span class="line"> thread_switch:</span><br><span class="line"><span class="deletion">-	/* YOUR CODE HERE */</span></span><br><span class="line"><span class="addition">+	/* Copy from kernel/swtch.S */</span></span><br><span class="line"><span class="addition">+	sd ra, 0(a0)</span></span><br><span class="line"><span class="addition">+	sd sp, 8(a0)</span></span><br><span class="line"><span class="addition">+	sd s0, 16(a0)</span></span><br><span class="line"><span class="addition">+	sd s1, 24(a0)</span></span><br><span class="line"><span class="addition">+	sd s2, 32(a0)</span></span><br><span class="line"><span class="addition">+	sd s3, 40(a0)</span></span><br><span class="line"><span class="addition">+	sd s4, 48(a0)</span></span><br><span class="line"><span class="addition">+	sd s5, 56(a0)</span></span><br><span class="line"><span class="addition">+	sd s6, 64(a0)</span></span><br><span class="line"><span class="addition">+	sd s7, 72(a0)</span></span><br><span class="line"><span class="addition">+	sd s8, 80(a0)</span></span><br><span class="line"><span class="addition">+	sd s9, 88(a0)</span></span><br><span class="line"><span class="addition">+	sd s10, 96(a0)</span></span><br><span class="line"><span class="addition">+	sd s11, 104(a0)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	ld ra, 0(a1)</span></span><br><span class="line"><span class="addition">+	ld sp, 8(a1)</span></span><br><span class="line"><span class="addition">+	ld s0, 16(a1)</span></span><br><span class="line"><span class="addition">+	ld s1, 24(a1)</span></span><br><span class="line"><span class="addition">+	ld s2, 32(a1)</span></span><br><span class="line"><span class="addition">+	ld s3, 40(a1)</span></span><br><span class="line"><span class="addition">+	ld s4, 48(a1)</span></span><br><span class="line"><span class="addition">+	ld s5, 56(a1)</span></span><br><span class="line"><span class="addition">+	ld s6, 64(a1)</span></span><br><span class="line"><span class="addition">+	ld s7, 72(a1)</span></span><br><span class="line"><span class="addition">+	ld s8, 80(a1)</span></span><br><span class="line"><span class="addition">+	ld s9, 88(a1)</span></span><br><span class="line"><span class="addition">+	ld s10, 96(a1)</span></span><br><span class="line"><span class="addition">+	ld s11, 104(a1)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	ret    /* return to ra */</span><br></pre></td></tr></table></figure>

<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><p>实现  bucket 级别锁利用多线程加速</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">make ph</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">./ph $(nproc)</span><br></pre></td></tr></table></figure>
<h3 id="Show-me-the-code-1"><a href="#Show-me-the-code-1" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/notxv6/ph.c b/notxv6/ph.c</span></span><br><span class="line"><span class="comment">index 09a72f3..c7b0050 100644</span></span><br><span class="line"><span class="comment">--- a/notxv6/ph.c</span></span><br><span class="line"><span class="comment">+++ b/notxv6/ph.c</span></span><br><span class="line"><span class="meta">@@ -17,6 +17,8 @@</span> struct entry *table[NBUCKET];</span><br><span class="line"> int keys[NKEYS];</span><br><span class="line"> int nthread = 1;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+pthread_mutex_t lock[NBUCKET]; // 定义锁</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> double</span><br><span class="line"> now()</span><br><span class="line"> &#123;</span><br><span class="line"><span class="meta">@@ -42,6 +44,7 @@</span> put(int key, int value)</span><br><span class="line"> </span><br><span class="line">   // is the key already present?</span><br><span class="line">   struct entry *e = 0;</span><br><span class="line"><span class="addition">+   pthread_mutex_lock(&amp;lock[i]); // 获取锁</span></span><br><span class="line">   for (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">     if (e-&gt;key == key)</span><br><span class="line">       break;</span><br><span class="line"><span class="meta">@@ -54,6 +57,7 @@</span> put(int key, int value)</span><br><span class="line">     // the new is new.</span><br><span class="line">     insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="addition">+   pthread_mutex_unlock(&amp;lock[i]); // 释放锁</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> static struct entry *</span><br><span class="line"><span class="meta">@@ -117,6 +121,11 @@</span> main(int argc, char *argv[])</span><br><span class="line">     keys[i] = random();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  // 初始化锁</span></span><br><span class="line"><span class="addition">+  for (int i = 0; i &lt; NBUCKET; i++) &#123;</span></span><br><span class="line"><span class="addition">+    pthread_mutex_init(&amp;lock[i], NULL);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   //</span><br><span class="line">   // first the puts</span><br><span class="line">   //</span><br></pre></td></tr></table></figure>

<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>posix 强相关，主打了解一个 posix 的 API， <code>broadcast</code> 这些函数日常码代码见到的不多。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">make barrier</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">./barrier</span><br></pre></td></tr></table></figure>
<h3 id="Show-me-the-code-2"><a href="#Show-me-the-code-2" class="headerlink" title="Show me the code"></a>Show me the code</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/notxv6/barrier.c b/notxv6/barrier.c</span></span><br><span class="line"><span class="comment">index bcad78f..a9768db 100644</span></span><br><span class="line"><span class="comment">--- a/notxv6/barrier.c</span></span><br><span class="line"><span class="comment">+++ b/notxv6/barrier.c</span></span><br><span class="line"><span class="meta">@@ -25,11 +25,20 @@</span> barrier_init(void)</span><br><span class="line"> static void</span><br><span class="line"> barrier()</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-  // YOUR CODE HERE</span></span><br><span class="line"><span class="deletion">-  //</span></span><br><span class="line"><span class="deletion">-  // Block until all threads have called barrier() and</span></span><br><span class="line"><span class="deletion">-  // then increment bstate.round.</span></span><br><span class="line"><span class="deletion">-  //</span></span><br><span class="line"><span class="addition">+  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  bstate.nthread++;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (bstate.nthread == nthread) &#123;</span></span><br><span class="line"><span class="addition">+    bstate.round++;</span></span><br><span class="line"><span class="addition">+    bstate.nthread = 0;</span></span><br><span class="line"><span class="addition">+    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  else &#123;</span></span><br><span class="line"><span class="addition">+    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> static void *</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make qemu-gdb</span><br><span class="line">uthread: OK (4.4s)</span><br><span class="line">== Test answers-thread.txt ==</span><br><span class="line">answers-thread.txt: OK</span><br><span class="line">== Test ph_safe == make[1]: Entering directory &#x27;/root/xv6-labs-2023&#x27;</span><br><span class="line">gcc -o ph -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/ph.c -pthread</span><br><span class="line">make[1]: Leaving directory &#x27;/root/xv6-labs-2023&#x27;</span><br><span class="line">ph_safe: OK (15.7s)</span><br><span class="line">== Test ph_fast == make[1]: Entering directory &#x27;/root/xv6-labs-2023&#x27;</span><br><span class="line">make[1]: &#x27;ph&#x27; is up to date.</span><br><span class="line">make[1]: Leaving directory &#x27;/root/xv6-labs-2023&#x27;</span><br><span class="line">ph_fast: OK (36.4s)</span><br><span class="line">== Test barrier == make[1]: Entering directory &#x27;/root/xv6-labs-2023&#x27;</span><br><span class="line">gcc -o barrier -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/barrier.c -pthread</span><br><span class="line">make[1]: Leaving directory &#x27;/root/xv6-labs-2023&#x27;</span><br><span class="line">barrier: OK (2.8s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 60/60</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
  </entry>
</search>
